import 'package:gpu_vector_tile_renderer/src/shaders/serializer/parsed_shader.dart';
import 'package:gpu_vector_tile_renderer/src/utils/string_utils.dart';

/// Generates the header for the shader bindings file.
String generateShaderBindingsHeader() {
  final o = StringBuffer();

  o.writeln('// GENERATED FILE - DO NOT MODIFY');
  o.writeln('// Generated by lib/src/shaders/bindings/shader_bindings_generator.dart');
  o.writeln();
  o.writeln('import \'package:gpu_vector_tile_renderer/_shaders.dart\';');
  o.writeln('import \'package:flutter_gpu/gpu.dart\' as gpu;');
  o.writeln('import \'package:vector_math/vector_math_64.dart\';');

  return o.toString();
}

/// Generates the common UBO bindings for a list of shaders.
String generateCommonShaderUboBindings(Iterable<ParsedShader> shaders) {
  final ubos = shaders.map((v) => v.ubos).expand((v) => v).toSet();

  final o = StringBuffer();

  // Generate UBO bindings
  for (final ubo in ubos) {
    final className = ubo.dartClassName;

    // -- Class declaration and constructor --
    o.writeln('/// Generated UBO bindings for `${ubo.name}`');
    o.writeln('class $className extends UniformBufferObjectBindings {');
    o.writeln(
      '  $className({required super.vertexShader, required super.fragmentShader}): super(name: \'${ubo.name}\');',
    );
    o.writeln('');

    // -- UBO setter --
    o.write('  void set({');
    for (var i = 0; i < ubo.variables.length; i++) {
      final variable = ubo.variables[i];
      o.write('required ${variable.dartType} ${variable.dartName()}');
      if (i != ubo.variables.length - 1) o.write(', ');
    }
    o.writeln('}) {');
    o.writeln('  if (slot == null) return;');
    o.writeln('');
    for (final variable in ubo.variables) {
      o.writeln(
        '    set_${variable.typeGlsl.value}(get_member_offset(slot!, \'${variable.name}\'), \$setData, ${variable.dartName()});',
      );
    }
    o.writeln('');
    o.writeln('    setInternal();');
    o.writeln('  }');

    // -- Closing --
    o.writeln('}');
    o.writeln();
  }

  return o.toString();
}

/// Generates the shader bindings for a given [vertexShader] and [fragmentShader].
String generateShaderBindings(ParsedShaderVertex vertexShader, ParsedShaderFragment fragmentShader) {
  final o = StringBuffer();

  //
  // Generate vertex shader bindings
  //

  // -- Class declaration and constructor --
  o.writeln('/// Generated bindings for the vertex shader `${vertexShader.name}`');
  o.writeln('class ${vertexShader.dartClassName} extends VertexShaderBindings {');
  o.writeln('  ${vertexShader.dartClassName}(ShaderLibraryProvider shaderLibraryProvider)');
  o.writeln('    : super(');
  o.writeln('        bytesPerVertex: ${vertexShader.bytesPerVertex},');
  o.writeln('        shader: ${_generateShaderLibraryGetter(vertexShader)},');
  o.writeln('      );');
  o.writeln('');

  // -- Vertex attribute setter --
  o.writeln('  /// Sets attributes for a vertex at [index].');
  o.writeln('  /// ');
  o.writeln('  /// Ensure that [allocateVertices] has been called before calling this method.');
  o.write('  void setVertex(int index, {');
  for (var i = 0; i < vertexShader.attributes.length; i++) {
    final attribute = vertexShader.attributes.elementAt(i);
    o.write('required ${attribute.dartType} ${attribute.dartName()}');
    if (attribute != vertexShader.attributes.last) o.write(', ');
  }
  o.writeln('}) {');
  var offset = 0;
  for (var i = 0; i < vertexShader.attributes.length; i++) {
    final attribute = vertexShader.attributes.elementAt(i);
    o.writeln('    set_${attribute.typeGlsl.value}($offset, \$setVertexData, ${attribute.dartName()});');
    offset += attribute.sizeInBytes;
  }
  o.writeln('');
  o.writeln('    setVertexInternal(index);');
  o.writeln('  }');
  o.writeln('');

  // -- Closing --
  o.writeln('}');
  o.writeln();

  //
  // Generate fragment shader bindings
  //

  // -- Class declaration
  o.writeln('/// Generated bindings for the fragment shader `${fragmentShader.name}`');
  o.writeln('class ${fragmentShader.dartClassName} extends FragmentShaderBindings {');
  o.writeln('  ${fragmentShader.dartClassName}(ShaderLibraryProvider shaderLibraryProvider)');
  o.writeln('    : super(');
  o.writeln('        shader: ${_generateShaderLibraryGetter(fragmentShader)},');
  o.writeln('      );');
  o.writeln('');

  // -- Closing --
  o.writeln('}');
  o.writeln();

  //
  // Generate pipeline bindings
  //

  final name = vertexShader.name;

  // -- Class declaration --
  o.writeln('/// Generated bindings for the render pipeline `$name`');
  o.writeln(
    'class ${nameToDartClassName(name)}RenderPipelineBindings extends RenderPipelineBindings<${vertexShader.dartClassName}, ${fragmentShader.dartClassName}> {',
  );
  o.writeln('  ${nameToDartClassName(name)}RenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)');
  o.writeln('      : super(');
  o.writeln('          vertex: ${vertexShader.dartClassName}(shaderLibraryProvider),');
  o.writeln('          fragment: ${fragmentShader.dartClassName}(shaderLibraryProvider),');
  o.writeln('          ubos: [');
  o.write(_generateShaderPipelineConstructorUbos(vertexShader, fragmentShader));
  o.writeln('          ],');
  o.writeln('          samplers: [');
  o.write(_generateShaderPipelineConstructorSamplers(vertexShader, fragmentShader));
  o.writeln('          ],');
  o.writeln('        );');

  if (vertexShader.ubos.isNotEmpty || fragmentShader.ubos.isNotEmpty) {
    // -- UBO getters --
    o.writeln('');
    o.write(_generateShaderPipelineUboGetters(vertexShader, fragmentShader));
    o.writeln('');

    // -- Sampler getters --
    o.write(_generateShaderPipelineSamplerGetters(vertexShader, fragmentShader));
    o.writeln('');

    // -- UBO setter --
    o.writeln(_generateShaderPipelineUniformSetter(vertexShader, fragmentShader));
  }

  // -- Closing --
  o.writeln('}');
  o.writeln();

  return o.toString();
}

/// Generates a getter for the relevant shader library.
String _generateShaderLibraryGetter(ParsedShader shader) {
  return 'shaderLibraryProvider[\'${shader.shaderBundleName}\']!';
}

/// Generates the initialization for UBOs in the shader pipeline constructor.
String _generateShaderPipelineConstructorUbos(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final ubos = {...vertexShader.ubos, ...fragmentShader.ubos};

  for (final ubo in ubos) {
    o.writeln(
      '            ${ubo.dartClassName}(vertexShader: ${_generateShaderLibraryGetter(vertexShader)}, fragmentShader: ${_generateShaderLibraryGetter(fragmentShader)}),',
    );
  }

  return o.toString();
}

/// Generates the initialization for samplers in the shader pipeline constructor.
String _generateShaderPipelineConstructorSamplers(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final samplers = {...vertexShader.samplers, ...fragmentShader.samplers};

  for (final sampler in samplers) {
    o.writeln(
      '            UniformSamplerBindings(name: \'${sampler.name}\', vertexShader: ${_generateShaderLibraryGetter(vertexShader)}, fragmentShader: ${_generateShaderLibraryGetter(fragmentShader)}),',
    );
  }

  return o.toString();
}

/// Generates the UBO getters for the shader pipeline.
String _generateShaderPipelineUboGetters(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final ubos = {...vertexShader.ubos, ...fragmentShader.ubos};

  for (var i = 0; i < ubos.length; i++) {
    final ubo = ubos.elementAt(i);
    o.writeln(
      '  late final ${ubo.dartClassName} ${nameToDartFieldName(ubo.dartClassName)} = ubos[$i] as ${ubo.dartClassName};',
    );
  }

  return o.toString();
}

/// Generates the uniform sampler getters for the shader pipeline.
String _generateShaderPipelineSamplerGetters(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final samplers = {...vertexShader.samplers, ...fragmentShader.samplers};

  for (var i = 0; i < samplers.length; i++) {
    final ubo = samplers.elementAt(i);
    o.writeln('  late final UniformSamplerBindings ${ubo.name} = samplers[$i];');
  }

  return o.toString();
}

/// Generates the uniform setter for the shader pipeline.
String _generateShaderPipelineUniformSetter(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final ubos = {...vertexShader.ubos, ...fragmentShader.ubos};
  final samplers = {...vertexShader.samplers, ...fragmentShader.samplers};

  o.writeln('  /// Sets the uniforms for this shader.');
  o.writeln('  void setUniforms({');
  for (var i = 0; i < ubos.length; i++) {
    final ubo = ubos.elementAt(i);
 
    for (var j = 0; j < ubo.variables.length; j++) {
      final variable = ubo.variables.elementAt(j);
      final paramName = nameToDartFieldName('${ubo.name}_${variable.dartName()}');
      o.write('required ${variable.dartType} $paramName');
      o.write(', ');
    }
  }
  for (var i = 0; i < samplers.length; i++) {
    final sampler = samplers.elementAt(i);
    final paramName = nameToDartFieldName('${sampler.name}Texture');
    o.write('required gpu.Texture $paramName');
    o.write(', ');
    o.write('gpu.SamplerOptions? ${paramName}SamplerOptions');
    o.write(', ');
  }
  o.writeln('}) {');
  for (final ubo in ubos) {
    o.writeln('    ${nameToDartFieldName(ubo.dartClassName)}.set(');
    for (var j = 0; j < ubo.variables.length; j++) {
      final variable = ubo.variables.elementAt(j);
      final paramName = nameToDartFieldName('${ubo.name}_${variable.dartName()}');
      o.write('${variable.dartName()}: $paramName');
      if (j != ubo.variables.length - 1) o.write(', ');
    }
    o.writeln(');');
  }

  for (final sampler in samplers) {
    final paramName = nameToDartFieldName('${sampler.name}Texture');
    o.writeln('    ${sampler.name}.setTexture($paramName, options: ${paramName}SamplerOptions);');
  }

  o.writeln('  }');

  return o.toString();
}
