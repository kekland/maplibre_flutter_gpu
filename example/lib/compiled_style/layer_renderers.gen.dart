// GENERATED FILE - DO NOT MODIFY
// Generated by lib/src/style_precompiler_2/style_precompiler.dart

// ignore_for_file: unused_local_variable, non_constant_identifier_names

import 'package:gpu_vector_tile_renderer/_controller.dart';
import 'package:gpu_vector_tile_renderer/_renderer.dart';
import 'package:gpu_vector_tile_renderer/_utils.dart';
import 'package:gpu_vector_tile_renderer/_spec.dart' as spec;
import 'package:gpu_vector_tile_renderer/_vector_tile.dart' as vt;
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter_map/flutter_map.dart';

import './shader_bindings.gen.dart';

const shaderBundleName = 'Streets Dark.shaderbundle';

SingleTileLayerRenderer? createSingleTileLayerRenderer(
  gpu.ShaderLibrary shaderLibrary,
  TileCoordinates coordinates,
  TileContainer container,
  spec.Layer specLayer,
  vt.Layer vtLayer,
) {
  return switch (specLayer.id) {
    'Background' => BackgroundLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Meadow' => MeadowLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Scrub' => ScrubLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Crop' => CropLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Glacier' => GlacierLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Forest' => ForestLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Sand' => SandLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Wood' => WoodLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Residential' => ResidentialLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Industrial' => IndustrialLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Grass' => GrassLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Airport zone' => AirportZoneLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Pedestrian' => PedestrianLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Cemetery' => CemeteryLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Hospital' => HospitalLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Stadium' => StadiumLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'School' => SchoolLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'River tunnel' => RiverTunnelLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'River' => RiverLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Water intermittent' => WaterIntermittentLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Water' => WaterLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Aeroway' => AerowayLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Heliport' => HeliportLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Ferry line' => FerryLineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Tunnel outline' => TunnelOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Tunnel' => TunnelLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Railway tunnel' => RailwayTunnelLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Railway tunnel hatching' => RailwayTunnelHatchingLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Footway tunnel outline' => FootwayTunnelOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Footway tunnel' => FootwayTunnelLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Pier' => PierLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Pier road' => PierRoadLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Bridge' => BridgeLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor road outline' => MinorRoadOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major road outline' => MajorRoadOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Highway outline' => HighwayOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Road under construction' => RoadUnderConstructionLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor road' => MinorRoadLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major road' => MajorRoadLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Highway' => HighwayLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Path outline' => PathOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Path minor' => PathMinorLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Path' => PathLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major rail' => MajorRailLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major rail hatching' => MajorRailHatchingLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor rail' => MinorRailLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor rail hatching' => MinorRailHatchingLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Building' => BuildingLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Aqueduct outline' => AqueductOutlineLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Aqueduct' => AqueductLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Cablecar' => CablecarLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Cablecar dash' => CablecarDashLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Other border' => OtherBorderLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Disputed border' => DisputedBorderLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Country border' => CountryBorderLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    _ => null,
  };
}

class BackgroundLayerRenderer extends $BackgroundLayerRenderer {
  BackgroundLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BackgroundRenderPipelineBindings(shaderLibrary);

  @override
  final BackgroundRenderPipelineBindings pipeline;

  @override
  void setVertices() {
    final paint = specLayer.paint;

    pipeline.vertex.setVertex(0, position: Vector2(-1, -1));
    pipeline.vertex.setVertex(1, position: Vector2(1, -1));
    pipeline.vertex.setVertex(2, position: Vector2(1, 1));
    pipeline.vertex.setVertex(3, position: Vector2(-1, 1));

    pipeline.upload(gpu.gpuContext);
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color = paint.backgroundColor.evaluate(eval).vec;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      backgroundUboColor: color,
    );
  }
}

class MeadowLayerRenderer extends $FillLayerRenderer {
  MeadowLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MeadowRenderPipelineBindings(shaderLibrary);

  @override
  final MeadowRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      meadowUboOpacityStops: opacity_stops,
    );
  }
}

class ScrubLayerRenderer extends $FillLayerRenderer {
  ScrubLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ScrubRenderPipelineBindings(shaderLibrary);

  @override
  final ScrubRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      scrubUboOpacityStops: opacity_stops,
    );
  }
}

class CropLayerRenderer extends $FillLayerRenderer {
  CropLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CropRenderPipelineBindings(shaderLibrary);

  @override
  final CropRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cropUboOpacityStops: opacity_stops,
    );
  }
}

class GlacierLayerRenderer extends $FillLayerRenderer {
  GlacierLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = GlacierRenderPipelineBindings(shaderLibrary);

  @override
  final GlacierRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 10.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 10.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 10.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 10.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      glacierUboOpacityStops: opacity_stops,
    );
  }
}

class ForestLayerRenderer extends $FillLayerRenderer {
  ForestLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ForestRenderPipelineBindings(shaderLibrary);

  @override
  final ForestRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [1.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [1.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [1.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [1.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      forestUboOpacityStops: opacity_stops,
    );
  }
}

class SandLayerRenderer extends $FillLayerRenderer {
  SandLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = SandRenderPipelineBindings(shaderLibrary);

  @override
  final SandRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class WoodLayerRenderer extends $FillLayerRenderer {
  WoodLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WoodRenderPipelineBindings(shaderLibrary);

  @override
  final WoodRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class ResidentialLayerRenderer extends $FillLayerRenderer {
  ResidentialLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ResidentialRenderPipelineBindings(shaderLibrary);

  @override
  final ResidentialRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [4.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [4.0, 16.0]),
              ),
            )
            .vec;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          colorStartValue: color_start_value,
          colorEndValue: color_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [4.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [4.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      residentialUboColorStops: color_stops,
    );
  }
}

class IndustrialLayerRenderer extends $FillLayerRenderer {
  IndustrialLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = IndustrialRenderPipelineBindings(shaderLibrary);

  @override
  final IndustrialRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 10.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 10.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 10.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 10.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      industrialUboOpacityStops: opacity_stops,
    );
  }
}

class GrassLayerRenderer extends $FillLayerRenderer {
  GrassLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = GrassRenderPipelineBindings(shaderLibrary);

  @override
  final GrassRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AirportZoneLayerRenderer extends $FillLayerRenderer {
  AirportZoneLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AirportZoneRenderPipelineBindings(shaderLibrary);

  @override
  final AirportZoneRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class PedestrianLayerRenderer extends $FillLayerRenderer {
  PedestrianLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PedestrianRenderPipelineBindings(shaderLibrary);

  @override
  final PedestrianRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class CemeteryLayerRenderer extends $FillLayerRenderer {
  CemeteryLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CemeteryRenderPipelineBindings(shaderLibrary);

  @override
  final CemeteryRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cemeteryUboOpacityStops: opacity_stops,
    );
  }
}

class HospitalLayerRenderer extends $FillLayerRenderer {
  HospitalLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HospitalRenderPipelineBindings(shaderLibrary);

  @override
  final HospitalRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      hospitalUboOpacityStops: opacity_stops,
    );
  }
}

class StadiumLayerRenderer extends $FillLayerRenderer {
  StadiumLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = StadiumRenderPipelineBindings(shaderLibrary);

  @override
  final StadiumRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      stadiumUboOpacityStops: opacity_stops,
    );
  }
}

class SchoolLayerRenderer extends $FillLayerRenderer {
  SchoolLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = SchoolRenderPipelineBindings(shaderLibrary);

  @override
  final SchoolRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      schoolUboOpacityStops: opacity_stops,
    );
  }
}

class RiverTunnelLayerRenderer extends $LineLayerRenderer {
  RiverTunnelLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RiverTunnelRenderPipelineBindings(shaderLibrary);

  @override
  final RiverTunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      riverTunnelUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      riverTunnelUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class RiverLayerRenderer extends $LineLayerRenderer {
  RiverLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RiverRenderPipelineBindings(shaderLibrary);

  @override
  final RiverRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      riverUboWidthStops: width_stops,
    );
  }
}

class WaterIntermittentLayerRenderer extends $FillLayerRenderer {
  WaterIntermittentLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WaterIntermittentRenderPipelineBindings(shaderLibrary);

  @override
  final WaterIntermittentRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class WaterLayerRenderer extends $FillLayerRenderer {
  WaterLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WaterRenderPipelineBindings(shaderLibrary);

  @override
  final WaterRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity = paint.fillOpacity.evaluate(eval).toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacity: opacity,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AerowayLayerRenderer extends $LineLayerRenderer {
  AerowayLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AerowayRenderPipelineBindings(shaderLibrary);

  @override
  final AerowayRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [11.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [11.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [11.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [11.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      aerowayUboWidthStops: width_stops,
    );
  }
}

class HeliportLayerRenderer extends $FillLayerRenderer {
  HeliportLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HeliportRenderPipelineBindings(shaderLibrary);

  @override
  final HeliportRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class FerryLineLayerRenderer extends $LineLayerRenderer {
  FerryLineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = FerryLineRenderPipelineBindings(shaderLibrary);

  @override
  final FerryLineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [10.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [10.0, 16.0]),
              ),
            )
            .vec;
    final opacity_start_value =
        paint.lineOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [6.0, 7.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.lineOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [6.0, 7.0, 8.0]),
              ),
            )
            .toDouble();
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [10.0, 14.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [10.0, 14.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        opacityStartValue: opacity_start_value,
        opacityEndValue: opacity_end_value,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [10.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [10.0, 16.0]),
    );
    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [6.0, 7.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [6.0, 7.0, 8.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [10.0, 14.0]),
      getNearestCeilValue(eval.zoom, const [10.0, 14.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      ferryLineUboColorStops: color_stops,
      ferryLineUboOpacityStops: opacity_stops,
      ferryLineUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      ferryLineUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class TunnelOutlineLayerRenderer extends $LineLayerRenderer {
  TunnelOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = TunnelOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final TunnelOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color = paint.lineColor.evaluate(eval).vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        color: color,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      tunnelOutlineUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      tunnelOutlineUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class TunnelLayerRenderer extends $LineLayerRenderer {
  TunnelLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = TunnelRenderPipelineBindings(shaderLibrary);

  @override
  final TunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color = paint.lineColor.evaluate(eval).vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        color: color,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      tunnelUboWidthStops: width_stops,
    );
  }
}

class RailwayTunnelLayerRenderer extends $LineLayerRenderer {
  RailwayTunnelLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RailwayTunnelRenderPipelineBindings(shaderLibrary);

  @override
  final RailwayTunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      railwayTunnelUboWidthStops: width_stops,
    );
  }
}

class RailwayTunnelHatchingLayerRenderer extends $LineLayerRenderer {
  RailwayTunnelHatchingLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RailwayTunnelHatchingRenderPipelineBindings(shaderLibrary);

  @override
  final RailwayTunnelHatchingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      railwayTunnelHatchingUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      railwayTunnelHatchingUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class FootwayTunnelOutlineLayerRenderer extends $LineLayerRenderer {
  FootwayTunnelOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = FootwayTunnelOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final FootwayTunnelOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      footwayTunnelOutlineUboWidthStops: width_stops,
    );
  }
}

class FootwayTunnelLayerRenderer extends $LineLayerRenderer {
  FootwayTunnelLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = FootwayTunnelRenderPipelineBindings(shaderLibrary);

  @override
  final FootwayTunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      footwayTunnelUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      footwayTunnelUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class PierLayerRenderer extends $FillLayerRenderer {
  PierLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PierRenderPipelineBindings(shaderLibrary);

  @override
  final PierRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class PierRoadLayerRenderer extends $LineLayerRenderer {
  PierRoadLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PierRoadRenderPipelineBindings(shaderLibrary);

  @override
  final PierRoadRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [15.0, 17.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [15.0, 17.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [15.0, 17.0]),
      getNearestCeilValue(eval.zoom, const [15.0, 17.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pierRoadUboWidthStops: width_stops,
    );
  }
}

class BridgeLayerRenderer extends $FillLayerRenderer {
  BridgeLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BridgeRenderPipelineBindings(shaderLibrary);

  @override
  final BridgeRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class MinorRoadOutlineLayerRenderer extends $LineLayerRenderer {
  MinorRoadOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRoadOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final MinorRoadOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [6.0, 7.0, 12.0, 14.0, 16.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [6.0, 7.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRoadOutlineUboWidthStops: width_stops,
    );
  }
}

class MajorRoadOutlineLayerRenderer extends $LineLayerRenderer {
  MajorRoadOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRoadOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final MajorRoadOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRoadOutlineUboWidthStops: width_stops,
    );
  }
}

class HighwayOutlineLayerRenderer extends $LineLayerRenderer {
  HighwayOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HighwayOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final HighwayOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      highwayOutlineUboWidthStops: width_stops,
    );
  }
}

class RoadUnderConstructionLayerRenderer extends $LineLayerRenderer {
  RoadUnderConstructionLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RoadUnderConstructionRenderPipelineBindings(shaderLibrary);

  @override
  final RoadUnderConstructionRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color = paint.lineColor.evaluate(eval).vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        color: color,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [5.0, 10.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      roadUnderConstructionUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      roadUnderConstructionUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class MinorRoadLayerRenderer extends $LineLayerRenderer {
  MinorRoadLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRoadRenderPipelineBindings(shaderLibrary);

  @override
  final MinorRoadRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [5.0, 10.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRoadUboWidthStops: width_stops,
    );
  }
}

class MajorRoadLayerRenderer extends $LineLayerRenderer {
  MajorRoadLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRoadRenderPipelineBindings(shaderLibrary);

  @override
  final MajorRoadRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 24.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 24.0]),
              ),
            )
            .vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 24.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 24.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [10.0, 12.0, 14.0, 16.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [10.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRoadUboColorStops: color_stops,
      majorRoadUboWidthStops: width_stops,
    );
  }
}

class HighwayLayerRenderer extends $LineLayerRenderer {
  HighwayLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HighwayRenderPipelineBindings(shaderLibrary);

  @override
  final HighwayRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 24.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 24.0]),
              ),
            )
            .vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 24.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 24.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      highwayUboColorStops: color_stops,
      highwayUboWidthStops: width_stops,
    );
  }
}

class PathOutlineLayerRenderer extends $LineLayerRenderer {
  PathOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PathOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final PathOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pathOutlineUboWidthStops: width_stops,
    );
  }
}

class PathMinorLayerRenderer extends $LineLayerRenderer {
  PathMinorLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PathMinorRenderPipelineBindings(shaderLibrary);

  @override
  final PathMinorRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pathMinorUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      pathMinorUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class PathLayerRenderer extends $LineLayerRenderer {
  PathLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PathRenderPipelineBindings(shaderLibrary);

  @override
  final PathRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pathUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      pathUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class MajorRailLayerRenderer extends $LineLayerRenderer {
  MajorRailLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRailRenderPipelineBindings(shaderLibrary);

  @override
  final MajorRailRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [8.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [8.0, 16.0]),
              ),
            )
            .vec;
    final opacity = paint.lineOpacity.evaluate(eval).toDouble();
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        opacity: opacity,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [8.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [8.0, 16.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRailUboColorStops: color_stops,
      majorRailUboWidthStops: width_stops,
    );
  }
}

class MajorRailHatchingLayerRenderer extends $LineLayerRenderer {
  MajorRailHatchingLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRailHatchingRenderPipelineBindings(shaderLibrary);

  @override
  final MajorRailHatchingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 16.0]),
              ),
            )
            .vec;
    final opacity = paint.lineOpacity.evaluate(eval).toDouble();
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        opacity: opacity,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 16.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRailHatchingUboColorStops: color_stops,
      majorRailHatchingUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      majorRailHatchingUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class MinorRailLayerRenderer extends $LineLayerRenderer {
  MinorRailLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRailRenderPipelineBindings(shaderLibrary);

  @override
  final MinorRailRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRailUboWidthStops: width_stops,
    );
  }
}

class MinorRailHatchingLayerRenderer extends $LineLayerRenderer {
  MinorRailHatchingLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRailHatchingRenderPipelineBindings(shaderLibrary);

  @override
  final MinorRailHatchingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRailHatchingUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      minorRailHatchingUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class BuildingLayerRenderer extends $FillLayerRenderer {
  BuildingLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BuildingRenderPipelineBindings(shaderLibrary);

  @override
  final BuildingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AqueductOutlineLayerRenderer extends $LineLayerRenderer {
  AqueductOutlineLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AqueductOutlineRenderPipelineBindings(shaderLibrary);

  @override
  final AqueductOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      aqueductOutlineUboWidthStops: width_stops,
    );
  }
}

class AqueductLayerRenderer extends $LineLayerRenderer {
  AqueductLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AqueductRenderPipelineBindings(shaderLibrary);

  @override
  final AqueductRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      aqueductUboWidthStops: width_stops,
    );
  }
}

class CablecarLayerRenderer extends $LineLayerRenderer {
  CablecarLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CablecarRenderPipelineBindings(shaderLibrary);

  @override
  final CablecarRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
      getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cablecarUboWidthStops: width_stops,
    );
  }
}

class CablecarDashLayerRenderer extends $LineLayerRenderer {
  CablecarDashLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CablecarDashRenderPipelineBindings(shaderLibrary);

  @override
  final CablecarDashRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
      getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cablecarDashUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      cablecarDashUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class OtherBorderLayerRenderer extends $LineLayerRenderer {
  OtherBorderLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = OtherBorderRenderPipelineBindings(shaderLibrary);

  @override
  final OtherBorderRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
      getNearestCeilValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      otherBorderUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      otherBorderUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class DisputedBorderLayerRenderer extends $LineLayerRenderer {
  DisputedBorderLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = DisputedBorderRenderPipelineBindings(shaderLibrary);

  @override
  final DisputedBorderRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0]),
      getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      disputedBorderUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      disputedBorderUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class CountryBorderLayerRenderer extends $LineLayerRenderer {
  CountryBorderLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CountryBorderRenderPipelineBindings(shaderLibrary);

  @override
  final CountryBorderRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
      getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      countryBorderUboWidthStops: width_stops,
    );
  }
}
