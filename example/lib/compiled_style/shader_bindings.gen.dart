// GENERATED FILE - DO NOT MODIFY
// Generated by lib/src/shaders/bindings/shader_bindings_generator.dart

import 'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings.dart';
import 'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings_utils.dart';
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:vector_math/vector_math_64.dart';

/// Generated UBO bindings for `BackgroundUbo`
class BackgroundUbo extends UniformBufferObjectBindings {
  BackgroundUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'BackgroundUbo');

  void set({required Vector4 color}) {
    if (slot == null) return;

    set_vec4(get_member_offset(slot!, 'color'), $setData, color);

    setInternal();
  }
}

/// Generated UBO bindings for `Tile`
class TileUbo extends UniformBufferObjectBindings {
  TileUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'Tile');

  void set({
    required Matrix4 localToGl,
    required double size,
    required double extent,
    required double opacity,
  }) {
    if (slot == null) return;

    set_mat4(get_member_offset(slot!, 'local_to_gl'), $setData, localToGl);
    set_float(get_member_offset(slot!, 'size'), $setData, size);
    set_float(get_member_offset(slot!, 'extent'), $setData, extent);
    set_float(get_member_offset(slot!, 'opacity'), $setData, opacity);

    setInternal();
  }
}

/// Generated UBO bindings for `Camera`
class CameraUbo extends UniformBufferObjectBindings {
  CameraUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'Camera');

  void set({
    required Matrix4 worldToGl,
    required double zoom,
    required double pixelRatio,
  }) {
    if (slot == null) return;

    set_mat4(get_member_offset(slot!, 'world_to_gl'), $setData, worldToGl);
    set_float(get_member_offset(slot!, 'zoom'), $setData, zoom);
    set_float(get_member_offset(slot!, 'pixel_ratio'), $setData, pixelRatio);

    setInternal();
  }
}

/// Generated UBO bindings for `MeadowUbo`
class MeadowUbo extends UniformBufferObjectBindings {
  MeadowUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MeadowUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `ScrubUbo`
class ScrubUbo extends UniformBufferObjectBindings {
  ScrubUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'ScrubUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CropUbo`
class CropUbo extends UniformBufferObjectBindings {
  CropUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CropUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `GlacierUbo`
class GlacierUbo extends UniformBufferObjectBindings {
  GlacierUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'GlacierUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `ForestUbo`
class ForestUbo extends UniformBufferObjectBindings {
  ForestUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'ForestUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `ResidentialUbo`
class ResidentialUbo extends UniformBufferObjectBindings {
  ResidentialUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'ResidentialUbo');

  void set({required Vector2 colorStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);

    setInternal();
  }
}

/// Generated UBO bindings for `IndustrialUbo`
class IndustrialUbo extends UniformBufferObjectBindings {
  IndustrialUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'IndustrialUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CemeteryUbo`
class CemeteryUbo extends UniformBufferObjectBindings {
  CemeteryUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CemeteryUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `HospitalUbo`
class HospitalUbo extends UniformBufferObjectBindings {
  HospitalUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'HospitalUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `StadiumUbo`
class StadiumUbo extends UniformBufferObjectBindings {
  StadiumUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'StadiumUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `SchoolUbo`
class SchoolUbo extends UniformBufferObjectBindings {
  SchoolUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'SchoolUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RiverTunnelUbo`
class RiverTunnelUbo extends UniformBufferObjectBindings {
  RiverTunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'RiverTunnelUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `RiverUbo`
class RiverUbo extends UniformBufferObjectBindings {
  RiverUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'RiverUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `AerowayUbo`
class AerowayUbo extends UniformBufferObjectBindings {
  AerowayUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'AerowayUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `FerryLineUbo`
class FerryLineUbo extends UniformBufferObjectBindings {
  FerryLineUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'FerryLineUbo');

  void set({
    required Vector2 colorStops,
    required Vector2 opacityStops,
    required Vector2 widthStops,
    required Vector2 dasharraySize,
  }) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `TunnelOutlineUbo`
class TunnelOutlineUbo extends UniformBufferObjectBindings {
  TunnelOutlineUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'TunnelOutlineUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `TunnelUbo`
class TunnelUbo extends UniformBufferObjectBindings {
  TunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'TunnelUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RailwayTunnelUbo`
class RailwayTunnelUbo extends UniformBufferObjectBindings {
  RailwayTunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'RailwayTunnelUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RailwayTunnelHatchingUbo`
class RailwayTunnelHatchingUbo extends UniformBufferObjectBindings {
  RailwayTunnelHatchingUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'RailwayTunnelHatchingUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `FootwayTunnelOutlineUbo`
class FootwayTunnelOutlineUbo extends UniformBufferObjectBindings {
  FootwayTunnelOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'FootwayTunnelOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `FootwayTunnelUbo`
class FootwayTunnelUbo extends UniformBufferObjectBindings {
  FootwayTunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'FootwayTunnelUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `PierRoadUbo`
class PierRoadUbo extends UniformBufferObjectBindings {
  PierRoadUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PierRoadUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRoadOutlineUbo`
class MinorRoadOutlineUbo extends UniformBufferObjectBindings {
  MinorRoadOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MinorRoadOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRoadOutlineUbo`
class MajorRoadOutlineUbo extends UniformBufferObjectBindings {
  MajorRoadOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MajorRoadOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `HighwayOutlineUbo`
class HighwayOutlineUbo extends UniformBufferObjectBindings {
  HighwayOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'HighwayOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RoadUnderConstructionUbo`
class RoadUnderConstructionUbo extends UniformBufferObjectBindings {
  RoadUnderConstructionUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'RoadUnderConstructionUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRoadUbo`
class MinorRoadUbo extends UniformBufferObjectBindings {
  MinorRoadUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MinorRoadUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRoadUbo`
class MajorRoadUbo extends UniformBufferObjectBindings {
  MajorRoadUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MajorRoadUbo');

  void set({required Vector2 colorStops, required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `HighwayUbo`
class HighwayUbo extends UniformBufferObjectBindings {
  HighwayUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'HighwayUbo');

  void set({required Vector2 colorStops, required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `PathOutlineUbo`
class PathOutlineUbo extends UniformBufferObjectBindings {
  PathOutlineUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PathOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `PathMinorUbo`
class PathMinorUbo extends UniformBufferObjectBindings {
  PathMinorUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PathMinorUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `PathUbo`
class PathUbo extends UniformBufferObjectBindings {
  PathUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PathUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRailUbo`
class MajorRailUbo extends UniformBufferObjectBindings {
  MajorRailUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MajorRailUbo');

  void set({required Vector2 colorStops, required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRailHatchingUbo`
class MajorRailHatchingUbo extends UniformBufferObjectBindings {
  MajorRailHatchingUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MajorRailHatchingUbo');

  void set({
    required Vector2 colorStops,
    required Vector2 widthStops,
    required Vector2 dasharraySize,
  }) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRailUbo`
class MinorRailUbo extends UniformBufferObjectBindings {
  MinorRailUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MinorRailUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRailHatchingUbo`
class MinorRailHatchingUbo extends UniformBufferObjectBindings {
  MinorRailHatchingUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MinorRailHatchingUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `AqueductOutlineUbo`
class AqueductOutlineUbo extends UniformBufferObjectBindings {
  AqueductOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'AqueductOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `AqueductUbo`
class AqueductUbo extends UniformBufferObjectBindings {
  AqueductUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'AqueductUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CablecarUbo`
class CablecarUbo extends UniformBufferObjectBindings {
  CablecarUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CablecarUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CablecarDashUbo`
class CablecarDashUbo extends UniformBufferObjectBindings {
  CablecarDashUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CablecarDashUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `OtherBorderUbo`
class OtherBorderUbo extends UniformBufferObjectBindings {
  OtherBorderUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'OtherBorderUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `DisputedBorderUbo`
class DisputedBorderUbo extends UniformBufferObjectBindings {
  DisputedBorderUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'DisputedBorderUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `CountryBorderUbo`
class CountryBorderUbo extends UniformBufferObjectBindings {
  CountryBorderUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CountryBorderUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated bindings for the vertex shader `background`
class BackgroundVertexShaderBindings extends VertexShaderBindings {
  BackgroundVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['background_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `background`
class BackgroundFragmentShaderBindings extends FragmentShaderBindings {
  BackgroundFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['background_frag']!);
}

/// Generated bindings for the render pipeline `background`
class BackgroundRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BackgroundVertexShaderBindings,
          BackgroundFragmentShaderBindings
        > {
  BackgroundRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: BackgroundVertexShaderBindings(shaderLibrary),
        fragment: BackgroundFragmentShaderBindings(shaderLibrary),
        ubos: [
          BackgroundUbo(
            vertexShader: shaderLibrary['background_vert']!,
            fragmentShader: shaderLibrary['background_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['background_vert']!,
            fragmentShader: shaderLibrary['background_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['background_vert']!,
            fragmentShader: shaderLibrary['background_frag']!,
          ),
        ],
        samplers: [],
      );

  late final BackgroundUbo backgroundUbo = ubos[0] as BackgroundUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector4 backgroundUboColor,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    backgroundUbo.set(color: backgroundUboColor);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `meadow`
class MeadowVertexShaderBindings extends VertexShaderBindings {
  MeadowVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['meadow_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `meadow`
class MeadowFragmentShaderBindings extends FragmentShaderBindings {
  MeadowFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['meadow_frag']!);
}

/// Generated bindings for the render pipeline `meadow`
class MeadowRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MeadowVertexShaderBindings,
          MeadowFragmentShaderBindings
        > {
  MeadowRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MeadowVertexShaderBindings(shaderLibrary),
        fragment: MeadowFragmentShaderBindings(shaderLibrary),
        ubos: [
          MeadowUbo(
            vertexShader: shaderLibrary['meadow_vert']!,
            fragmentShader: shaderLibrary['meadow_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['meadow_vert']!,
            fragmentShader: shaderLibrary['meadow_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['meadow_vert']!,
            fragmentShader: shaderLibrary['meadow_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MeadowUbo meadowUbo = ubos[0] as MeadowUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 meadowUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    meadowUbo.set(opacityStops: meadowUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `scrub`
class ScrubVertexShaderBindings extends VertexShaderBindings {
  ScrubVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['scrub_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `scrub`
class ScrubFragmentShaderBindings extends FragmentShaderBindings {
  ScrubFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['scrub_frag']!);
}

/// Generated bindings for the render pipeline `scrub`
class ScrubRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ScrubVertexShaderBindings,
          ScrubFragmentShaderBindings
        > {
  ScrubRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: ScrubVertexShaderBindings(shaderLibrary),
        fragment: ScrubFragmentShaderBindings(shaderLibrary),
        ubos: [
          ScrubUbo(
            vertexShader: shaderLibrary['scrub_vert']!,
            fragmentShader: shaderLibrary['scrub_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['scrub_vert']!,
            fragmentShader: shaderLibrary['scrub_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['scrub_vert']!,
            fragmentShader: shaderLibrary['scrub_frag']!,
          ),
        ],
        samplers: [],
      );

  late final ScrubUbo scrubUbo = ubos[0] as ScrubUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 scrubUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    scrubUbo.set(opacityStops: scrubUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `crop`
class CropVertexShaderBindings extends VertexShaderBindings {
  CropVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['crop_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `crop`
class CropFragmentShaderBindings extends FragmentShaderBindings {
  CropFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['crop_frag']!);
}

/// Generated bindings for the render pipeline `crop`
class CropRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CropVertexShaderBindings,
          CropFragmentShaderBindings
        > {
  CropRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CropVertexShaderBindings(shaderLibrary),
        fragment: CropFragmentShaderBindings(shaderLibrary),
        ubos: [
          CropUbo(
            vertexShader: shaderLibrary['crop_vert']!,
            fragmentShader: shaderLibrary['crop_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['crop_vert']!,
            fragmentShader: shaderLibrary['crop_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['crop_vert']!,
            fragmentShader: shaderLibrary['crop_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CropUbo cropUbo = ubos[0] as CropUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cropUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    cropUbo.set(opacityStops: cropUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `glacier`
class GlacierVertexShaderBindings extends VertexShaderBindings {
  GlacierVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['glacier_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `glacier`
class GlacierFragmentShaderBindings extends FragmentShaderBindings {
  GlacierFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['glacier_frag']!);
}

/// Generated bindings for the render pipeline `glacier`
class GlacierRenderPipelineBindings
    extends
        RenderPipelineBindings<
          GlacierVertexShaderBindings,
          GlacierFragmentShaderBindings
        > {
  GlacierRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: GlacierVertexShaderBindings(shaderLibrary),
        fragment: GlacierFragmentShaderBindings(shaderLibrary),
        ubos: [
          GlacierUbo(
            vertexShader: shaderLibrary['glacier_vert']!,
            fragmentShader: shaderLibrary['glacier_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['glacier_vert']!,
            fragmentShader: shaderLibrary['glacier_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['glacier_vert']!,
            fragmentShader: shaderLibrary['glacier_frag']!,
          ),
        ],
        samplers: [],
      );

  late final GlacierUbo glacierUbo = ubos[0] as GlacierUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 glacierUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    glacierUbo.set(opacityStops: glacierUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `forest`
class ForestVertexShaderBindings extends VertexShaderBindings {
  ForestVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['forest_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `forest`
class ForestFragmentShaderBindings extends FragmentShaderBindings {
  ForestFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['forest_frag']!);
}

/// Generated bindings for the render pipeline `forest`
class ForestRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ForestVertexShaderBindings,
          ForestFragmentShaderBindings
        > {
  ForestRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: ForestVertexShaderBindings(shaderLibrary),
        fragment: ForestFragmentShaderBindings(shaderLibrary),
        ubos: [
          ForestUbo(
            vertexShader: shaderLibrary['forest_vert']!,
            fragmentShader: shaderLibrary['forest_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['forest_vert']!,
            fragmentShader: shaderLibrary['forest_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['forest_vert']!,
            fragmentShader: shaderLibrary['forest_frag']!,
          ),
        ],
        samplers: [],
      );

  late final ForestUbo forestUbo = ubos[0] as ForestUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 forestUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    forestUbo.set(opacityStops: forestUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `sand`
class SandVertexShaderBindings extends VertexShaderBindings {
  SandVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['sand_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `sand`
class SandFragmentShaderBindings extends FragmentShaderBindings {
  SandFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['sand_frag']!);
}

/// Generated bindings for the render pipeline `sand`
class SandRenderPipelineBindings
    extends
        RenderPipelineBindings<
          SandVertexShaderBindings,
          SandFragmentShaderBindings
        > {
  SandRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: SandVertexShaderBindings(shaderLibrary),
        fragment: SandFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['sand_vert']!,
            fragmentShader: shaderLibrary['sand_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['sand_vert']!,
            fragmentShader: shaderLibrary['sand_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `wood`
class WoodVertexShaderBindings extends VertexShaderBindings {
  WoodVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['wood_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `wood`
class WoodFragmentShaderBindings extends FragmentShaderBindings {
  WoodFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['wood_frag']!);
}

/// Generated bindings for the render pipeline `wood`
class WoodRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WoodVertexShaderBindings,
          WoodFragmentShaderBindings
        > {
  WoodRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: WoodVertexShaderBindings(shaderLibrary),
        fragment: WoodFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['wood_vert']!,
            fragmentShader: shaderLibrary['wood_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['wood_vert']!,
            fragmentShader: shaderLibrary['wood_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `residential`
class ResidentialVertexShaderBindings extends VertexShaderBindings {
  ResidentialVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 40, shader: shaderLibrary['residential_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec4(8, $setVertexData, colorStartValue);
    set_vec4(24, $setVertexData, colorEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `residential`
class ResidentialFragmentShaderBindings extends FragmentShaderBindings {
  ResidentialFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['residential_frag']!);
}

/// Generated bindings for the render pipeline `residential`
class ResidentialRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ResidentialVertexShaderBindings,
          ResidentialFragmentShaderBindings
        > {
  ResidentialRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: ResidentialVertexShaderBindings(shaderLibrary),
        fragment: ResidentialFragmentShaderBindings(shaderLibrary),
        ubos: [
          ResidentialUbo(
            vertexShader: shaderLibrary['residential_vert']!,
            fragmentShader: shaderLibrary['residential_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['residential_vert']!,
            fragmentShader: shaderLibrary['residential_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['residential_vert']!,
            fragmentShader: shaderLibrary['residential_frag']!,
          ),
        ],
        samplers: [],
      );

  late final ResidentialUbo residentialUbo = ubos[0] as ResidentialUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 residentialUboColorStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    residentialUbo.set(colorStops: residentialUboColorStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `industrial`
class IndustrialVertexShaderBindings extends VertexShaderBindings {
  IndustrialVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['industrial_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `industrial`
class IndustrialFragmentShaderBindings extends FragmentShaderBindings {
  IndustrialFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['industrial_frag']!);
}

/// Generated bindings for the render pipeline `industrial`
class IndustrialRenderPipelineBindings
    extends
        RenderPipelineBindings<
          IndustrialVertexShaderBindings,
          IndustrialFragmentShaderBindings
        > {
  IndustrialRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: IndustrialVertexShaderBindings(shaderLibrary),
        fragment: IndustrialFragmentShaderBindings(shaderLibrary),
        ubos: [
          IndustrialUbo(
            vertexShader: shaderLibrary['industrial_vert']!,
            fragmentShader: shaderLibrary['industrial_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['industrial_vert']!,
            fragmentShader: shaderLibrary['industrial_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['industrial_vert']!,
            fragmentShader: shaderLibrary['industrial_frag']!,
          ),
        ],
        samplers: [],
      );

  late final IndustrialUbo industrialUbo = ubos[0] as IndustrialUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 industrialUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    industrialUbo.set(opacityStops: industrialUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `grass`
class GrassVertexShaderBindings extends VertexShaderBindings {
  GrassVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['grass_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `grass`
class GrassFragmentShaderBindings extends FragmentShaderBindings {
  GrassFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['grass_frag']!);
}

/// Generated bindings for the render pipeline `grass`
class GrassRenderPipelineBindings
    extends
        RenderPipelineBindings<
          GrassVertexShaderBindings,
          GrassFragmentShaderBindings
        > {
  GrassRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: GrassVertexShaderBindings(shaderLibrary),
        fragment: GrassFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['grass_vert']!,
            fragmentShader: shaderLibrary['grass_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['grass_vert']!,
            fragmentShader: shaderLibrary['grass_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `airport_zone`
class AirportZoneVertexShaderBindings extends VertexShaderBindings {
  AirportZoneVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['airport_zone_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `airport_zone`
class AirportZoneFragmentShaderBindings extends FragmentShaderBindings {
  AirportZoneFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['airport_zone_frag']!);
}

/// Generated bindings for the render pipeline `airport_zone`
class AirportZoneRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AirportZoneVertexShaderBindings,
          AirportZoneFragmentShaderBindings
        > {
  AirportZoneRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: AirportZoneVertexShaderBindings(shaderLibrary),
        fragment: AirportZoneFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['airport_zone_vert']!,
            fragmentShader: shaderLibrary['airport_zone_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['airport_zone_vert']!,
            fragmentShader: shaderLibrary['airport_zone_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `pedestrian`
class PedestrianVertexShaderBindings extends VertexShaderBindings {
  PedestrianVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['pedestrian_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `pedestrian`
class PedestrianFragmentShaderBindings extends FragmentShaderBindings {
  PedestrianFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['pedestrian_frag']!);
}

/// Generated bindings for the render pipeline `pedestrian`
class PedestrianRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PedestrianVertexShaderBindings,
          PedestrianFragmentShaderBindings
        > {
  PedestrianRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PedestrianVertexShaderBindings(shaderLibrary),
        fragment: PedestrianFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['pedestrian_vert']!,
            fragmentShader: shaderLibrary['pedestrian_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['pedestrian_vert']!,
            fragmentShader: shaderLibrary['pedestrian_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `cemetery`
class CemeteryVertexShaderBindings extends VertexShaderBindings {
  CemeteryVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['cemetery_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `cemetery`
class CemeteryFragmentShaderBindings extends FragmentShaderBindings {
  CemeteryFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['cemetery_frag']!);
}

/// Generated bindings for the render pipeline `cemetery`
class CemeteryRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CemeteryVertexShaderBindings,
          CemeteryFragmentShaderBindings
        > {
  CemeteryRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CemeteryVertexShaderBindings(shaderLibrary),
        fragment: CemeteryFragmentShaderBindings(shaderLibrary),
        ubos: [
          CemeteryUbo(
            vertexShader: shaderLibrary['cemetery_vert']!,
            fragmentShader: shaderLibrary['cemetery_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['cemetery_vert']!,
            fragmentShader: shaderLibrary['cemetery_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['cemetery_vert']!,
            fragmentShader: shaderLibrary['cemetery_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CemeteryUbo cemeteryUbo = ubos[0] as CemeteryUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cemeteryUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    cemeteryUbo.set(opacityStops: cemeteryUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `hospital`
class HospitalVertexShaderBindings extends VertexShaderBindings {
  HospitalVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['hospital_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `hospital`
class HospitalFragmentShaderBindings extends FragmentShaderBindings {
  HospitalFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['hospital_frag']!);
}

/// Generated bindings for the render pipeline `hospital`
class HospitalRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HospitalVertexShaderBindings,
          HospitalFragmentShaderBindings
        > {
  HospitalRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: HospitalVertexShaderBindings(shaderLibrary),
        fragment: HospitalFragmentShaderBindings(shaderLibrary),
        ubos: [
          HospitalUbo(
            vertexShader: shaderLibrary['hospital_vert']!,
            fragmentShader: shaderLibrary['hospital_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['hospital_vert']!,
            fragmentShader: shaderLibrary['hospital_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['hospital_vert']!,
            fragmentShader: shaderLibrary['hospital_frag']!,
          ),
        ],
        samplers: [],
      );

  late final HospitalUbo hospitalUbo = ubos[0] as HospitalUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 hospitalUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    hospitalUbo.set(opacityStops: hospitalUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `stadium`
class StadiumVertexShaderBindings extends VertexShaderBindings {
  StadiumVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['stadium_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `stadium`
class StadiumFragmentShaderBindings extends FragmentShaderBindings {
  StadiumFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['stadium_frag']!);
}

/// Generated bindings for the render pipeline `stadium`
class StadiumRenderPipelineBindings
    extends
        RenderPipelineBindings<
          StadiumVertexShaderBindings,
          StadiumFragmentShaderBindings
        > {
  StadiumRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: StadiumVertexShaderBindings(shaderLibrary),
        fragment: StadiumFragmentShaderBindings(shaderLibrary),
        ubos: [
          StadiumUbo(
            vertexShader: shaderLibrary['stadium_vert']!,
            fragmentShader: shaderLibrary['stadium_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['stadium_vert']!,
            fragmentShader: shaderLibrary['stadium_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['stadium_vert']!,
            fragmentShader: shaderLibrary['stadium_frag']!,
          ),
        ],
        samplers: [],
      );

  late final StadiumUbo stadiumUbo = ubos[0] as StadiumUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 stadiumUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    stadiumUbo.set(opacityStops: stadiumUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `school`
class SchoolVertexShaderBindings extends VertexShaderBindings {
  SchoolVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['school_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `school`
class SchoolFragmentShaderBindings extends FragmentShaderBindings {
  SchoolFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['school_frag']!);
}

/// Generated bindings for the render pipeline `school`
class SchoolRenderPipelineBindings
    extends
        RenderPipelineBindings<
          SchoolVertexShaderBindings,
          SchoolFragmentShaderBindings
        > {
  SchoolRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: SchoolVertexShaderBindings(shaderLibrary),
        fragment: SchoolFragmentShaderBindings(shaderLibrary),
        ubos: [
          SchoolUbo(
            vertexShader: shaderLibrary['school_vert']!,
            fragmentShader: shaderLibrary['school_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['school_vert']!,
            fragmentShader: shaderLibrary['school_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['school_vert']!,
            fragmentShader: shaderLibrary['school_frag']!,
          ),
        ],
        samplers: [],
      );

  late final SchoolUbo schoolUbo = ubos[0] as SchoolUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 schoolUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    schoolUbo.set(opacityStops: schoolUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `river_tunnel`
class RiverTunnelVertexShaderBindings extends VertexShaderBindings {
  RiverTunnelVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['river_tunnel_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `river_tunnel`
class RiverTunnelFragmentShaderBindings extends FragmentShaderBindings {
  RiverTunnelFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['river_tunnel_frag']!);
}

/// Generated bindings for the render pipeline `river_tunnel`
class RiverTunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RiverTunnelVertexShaderBindings,
          RiverTunnelFragmentShaderBindings
        > {
  RiverTunnelRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: RiverTunnelVertexShaderBindings(shaderLibrary),
        fragment: RiverTunnelFragmentShaderBindings(shaderLibrary),
        ubos: [
          RiverTunnelUbo(
            vertexShader: shaderLibrary['river_tunnel_vert']!,
            fragmentShader: shaderLibrary['river_tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['river_tunnel_vert']!,
            fragmentShader: shaderLibrary['river_tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['river_tunnel_vert']!,
            fragmentShader: shaderLibrary['river_tunnel_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['river_tunnel_vert']!,
            fragmentShader: shaderLibrary['river_tunnel_frag']!,
          ),
        ],
      );

  late final RiverTunnelUbo riverTunnelUbo = ubos[0] as RiverTunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 riverTunnelUboWidthStops,
    required Vector2 riverTunnelUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    riverTunnelUbo.set(
      widthStops: riverTunnelUboWidthStops,
      dasharraySize: riverTunnelUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `river`
class RiverVertexShaderBindings extends VertexShaderBindings {
  RiverVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['river_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `river`
class RiverFragmentShaderBindings extends FragmentShaderBindings {
  RiverFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['river_frag']!);
}

/// Generated bindings for the render pipeline `river`
class RiverRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RiverVertexShaderBindings,
          RiverFragmentShaderBindings
        > {
  RiverRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: RiverVertexShaderBindings(shaderLibrary),
        fragment: RiverFragmentShaderBindings(shaderLibrary),
        ubos: [
          RiverUbo(
            vertexShader: shaderLibrary['river_vert']!,
            fragmentShader: shaderLibrary['river_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['river_vert']!,
            fragmentShader: shaderLibrary['river_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['river_vert']!,
            fragmentShader: shaderLibrary['river_frag']!,
          ),
        ],
        samplers: [],
      );

  late final RiverUbo riverUbo = ubos[0] as RiverUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 riverUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    riverUbo.set(widthStops: riverUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `water_intermittent`
class WaterIntermittentVertexShaderBindings extends VertexShaderBindings {
  WaterIntermittentVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 8,
        shader: shaderLibrary['water_intermittent_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `water_intermittent`
class WaterIntermittentFragmentShaderBindings extends FragmentShaderBindings {
  WaterIntermittentFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['water_intermittent_frag']!);
}

/// Generated bindings for the render pipeline `water_intermittent`
class WaterIntermittentRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WaterIntermittentVertexShaderBindings,
          WaterIntermittentFragmentShaderBindings
        > {
  WaterIntermittentRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: WaterIntermittentVertexShaderBindings(shaderLibrary),
        fragment: WaterIntermittentFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['water_intermittent_vert']!,
            fragmentShader: shaderLibrary['water_intermittent_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['water_intermittent_vert']!,
            fragmentShader: shaderLibrary['water_intermittent_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `water`
class WaterVertexShaderBindings extends VertexShaderBindings {
  WaterVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 12, shader: shaderLibrary['water_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacity,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacity);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `water`
class WaterFragmentShaderBindings extends FragmentShaderBindings {
  WaterFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['water_frag']!);
}

/// Generated bindings for the render pipeline `water`
class WaterRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WaterVertexShaderBindings,
          WaterFragmentShaderBindings
        > {
  WaterRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: WaterVertexShaderBindings(shaderLibrary),
        fragment: WaterFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['water_vert']!,
            fragmentShader: shaderLibrary['water_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['water_vert']!,
            fragmentShader: shaderLibrary['water_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `aeroway`
class AerowayVertexShaderBindings extends VertexShaderBindings {
  AerowayVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['aeroway_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `aeroway`
class AerowayFragmentShaderBindings extends FragmentShaderBindings {
  AerowayFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['aeroway_frag']!);
}

/// Generated bindings for the render pipeline `aeroway`
class AerowayRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AerowayVertexShaderBindings,
          AerowayFragmentShaderBindings
        > {
  AerowayRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: AerowayVertexShaderBindings(shaderLibrary),
        fragment: AerowayFragmentShaderBindings(shaderLibrary),
        ubos: [
          AerowayUbo(
            vertexShader: shaderLibrary['aeroway_vert']!,
            fragmentShader: shaderLibrary['aeroway_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['aeroway_vert']!,
            fragmentShader: shaderLibrary['aeroway_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['aeroway_vert']!,
            fragmentShader: shaderLibrary['aeroway_frag']!,
          ),
        ],
        samplers: [],
      );

  late final AerowayUbo aerowayUbo = ubos[0] as AerowayUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 aerowayUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    aerowayUbo.set(widthStops: aerowayUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `heliport`
class HeliportVertexShaderBindings extends VertexShaderBindings {
  HeliportVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['heliport_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `heliport`
class HeliportFragmentShaderBindings extends FragmentShaderBindings {
  HeliportFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['heliport_frag']!);
}

/// Generated bindings for the render pipeline `heliport`
class HeliportRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HeliportVertexShaderBindings,
          HeliportFragmentShaderBindings
        > {
  HeliportRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: HeliportVertexShaderBindings(shaderLibrary),
        fragment: HeliportFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['heliport_vert']!,
            fragmentShader: shaderLibrary['heliport_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['heliport_vert']!,
            fragmentShader: shaderLibrary['heliport_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `ferry_line`
class FerryLineVertexShaderBindings extends VertexShaderBindings {
  FerryLineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 68, shader: shaderLibrary['ferry_line_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double opacityStartValue,
    required double opacityEndValue,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, colorStartValue);
    set_vec4(36, $setVertexData, colorEndValue);
    set_float(52, $setVertexData, opacityStartValue);
    set_float(56, $setVertexData, opacityEndValue);
    set_float(60, $setVertexData, widthStartValue);
    set_float(64, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `ferry_line`
class FerryLineFragmentShaderBindings extends FragmentShaderBindings {
  FerryLineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['ferry_line_frag']!);
}

/// Generated bindings for the render pipeline `ferry_line`
class FerryLineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          FerryLineVertexShaderBindings,
          FerryLineFragmentShaderBindings
        > {
  FerryLineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: FerryLineVertexShaderBindings(shaderLibrary),
        fragment: FerryLineFragmentShaderBindings(shaderLibrary),
        ubos: [
          FerryLineUbo(
            vertexShader: shaderLibrary['ferry_line_vert']!,
            fragmentShader: shaderLibrary['ferry_line_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['ferry_line_vert']!,
            fragmentShader: shaderLibrary['ferry_line_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['ferry_line_vert']!,
            fragmentShader: shaderLibrary['ferry_line_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['ferry_line_vert']!,
            fragmentShader: shaderLibrary['ferry_line_frag']!,
          ),
        ],
      );

  late final FerryLineUbo ferryLineUbo = ubos[0] as FerryLineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 ferryLineUboColorStops,
    required Vector2 ferryLineUboOpacityStops,
    required Vector2 ferryLineUboWidthStops,
    required Vector2 ferryLineUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    ferryLineUbo.set(
      colorStops: ferryLineUboColorStops,
      opacityStops: ferryLineUboOpacityStops,
      widthStops: ferryLineUboWidthStops,
      dasharraySize: ferryLineUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `tunnel_outline`
class TunnelOutlineVertexShaderBindings extends VertexShaderBindings {
  TunnelOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 44, shader: shaderLibrary['tunnel_outline_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 color,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, color);
    set_float(36, $setVertexData, widthStartValue);
    set_float(40, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `tunnel_outline`
class TunnelOutlineFragmentShaderBindings extends FragmentShaderBindings {
  TunnelOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['tunnel_outline_frag']!);
}

/// Generated bindings for the render pipeline `tunnel_outline`
class TunnelOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          TunnelOutlineVertexShaderBindings,
          TunnelOutlineFragmentShaderBindings
        > {
  TunnelOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: TunnelOutlineVertexShaderBindings(shaderLibrary),
        fragment: TunnelOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          TunnelOutlineUbo(
            vertexShader: shaderLibrary['tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['tunnel_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['tunnel_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['tunnel_outline_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['tunnel_outline_frag']!,
          ),
        ],
      );

  late final TunnelOutlineUbo tunnelOutlineUbo = ubos[0] as TunnelOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 tunnelOutlineUboWidthStops,
    required Vector2 tunnelOutlineUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    tunnelOutlineUbo.set(
      widthStops: tunnelOutlineUboWidthStops,
      dasharraySize: tunnelOutlineUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `tunnel`
class TunnelVertexShaderBindings extends VertexShaderBindings {
  TunnelVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 40, shader: shaderLibrary['tunnel_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required Vector4 color,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_vec4(16, $setVertexData, color);
    set_float(32, $setVertexData, widthStartValue);
    set_float(36, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `tunnel`
class TunnelFragmentShaderBindings extends FragmentShaderBindings {
  TunnelFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['tunnel_frag']!);
}

/// Generated bindings for the render pipeline `tunnel`
class TunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          TunnelVertexShaderBindings,
          TunnelFragmentShaderBindings
        > {
  TunnelRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: TunnelVertexShaderBindings(shaderLibrary),
        fragment: TunnelFragmentShaderBindings(shaderLibrary),
        ubos: [
          TunnelUbo(
            vertexShader: shaderLibrary['tunnel_vert']!,
            fragmentShader: shaderLibrary['tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['tunnel_vert']!,
            fragmentShader: shaderLibrary['tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['tunnel_vert']!,
            fragmentShader: shaderLibrary['tunnel_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TunnelUbo tunnelUbo = ubos[0] as TunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 tunnelUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tunnelUbo.set(widthStops: tunnelUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `railway_tunnel`
class RailwayTunnelVertexShaderBindings extends VertexShaderBindings {
  RailwayTunnelVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['railway_tunnel_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `railway_tunnel`
class RailwayTunnelFragmentShaderBindings extends FragmentShaderBindings {
  RailwayTunnelFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['railway_tunnel_frag']!);
}

/// Generated bindings for the render pipeline `railway_tunnel`
class RailwayTunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RailwayTunnelVertexShaderBindings,
          RailwayTunnelFragmentShaderBindings
        > {
  RailwayTunnelRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: RailwayTunnelVertexShaderBindings(shaderLibrary),
        fragment: RailwayTunnelFragmentShaderBindings(shaderLibrary),
        ubos: [
          RailwayTunnelUbo(
            vertexShader: shaderLibrary['railway_tunnel_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['railway_tunnel_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['railway_tunnel_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_frag']!,
          ),
        ],
        samplers: [],
      );

  late final RailwayTunnelUbo railwayTunnelUbo = ubos[0] as RailwayTunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 railwayTunnelUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    railwayTunnelUbo.set(widthStops: railwayTunnelUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `railway_tunnel_hatching`
class RailwayTunnelHatchingVertexShaderBindings extends VertexShaderBindings {
  RailwayTunnelHatchingVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 28,
        shader: shaderLibrary['railway_tunnel_hatching_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `railway_tunnel_hatching`
class RailwayTunnelHatchingFragmentShaderBindings
    extends FragmentShaderBindings {
  RailwayTunnelHatchingFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['railway_tunnel_hatching_frag']!);
}

/// Generated bindings for the render pipeline `railway_tunnel_hatching`
class RailwayTunnelHatchingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RailwayTunnelHatchingVertexShaderBindings,
          RailwayTunnelHatchingFragmentShaderBindings
        > {
  RailwayTunnelHatchingRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: RailwayTunnelHatchingVertexShaderBindings(shaderLibrary),
        fragment: RailwayTunnelHatchingFragmentShaderBindings(shaderLibrary),
        ubos: [
          RailwayTunnelHatchingUbo(
            vertexShader: shaderLibrary['railway_tunnel_hatching_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_hatching_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['railway_tunnel_hatching_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_hatching_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['railway_tunnel_hatching_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_hatching_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['railway_tunnel_hatching_vert']!,
            fragmentShader: shaderLibrary['railway_tunnel_hatching_frag']!,
          ),
        ],
      );

  late final RailwayTunnelHatchingUbo railwayTunnelHatchingUbo =
      ubos[0] as RailwayTunnelHatchingUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 railwayTunnelHatchingUboWidthStops,
    required Vector2 railwayTunnelHatchingUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    railwayTunnelHatchingUbo.set(
      widthStops: railwayTunnelHatchingUboWidthStops,
      dasharraySize: railwayTunnelHatchingUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `footway_tunnel_outline`
class FootwayTunnelOutlineVertexShaderBindings extends VertexShaderBindings {
  FootwayTunnelOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibrary['footway_tunnel_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `footway_tunnel_outline`
class FootwayTunnelOutlineFragmentShaderBindings
    extends FragmentShaderBindings {
  FootwayTunnelOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['footway_tunnel_outline_frag']!);
}

/// Generated bindings for the render pipeline `footway_tunnel_outline`
class FootwayTunnelOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          FootwayTunnelOutlineVertexShaderBindings,
          FootwayTunnelOutlineFragmentShaderBindings
        > {
  FootwayTunnelOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: FootwayTunnelOutlineVertexShaderBindings(shaderLibrary),
        fragment: FootwayTunnelOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          FootwayTunnelOutlineUbo(
            vertexShader: shaderLibrary['footway_tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['footway_tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['footway_tunnel_outline_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final FootwayTunnelOutlineUbo footwayTunnelOutlineUbo =
      ubos[0] as FootwayTunnelOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 footwayTunnelOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    footwayTunnelOutlineUbo.set(widthStops: footwayTunnelOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `footway_tunnel`
class FootwayTunnelVertexShaderBindings extends VertexShaderBindings {
  FootwayTunnelVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['footway_tunnel_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `footway_tunnel`
class FootwayTunnelFragmentShaderBindings extends FragmentShaderBindings {
  FootwayTunnelFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['footway_tunnel_frag']!);
}

/// Generated bindings for the render pipeline `footway_tunnel`
class FootwayTunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          FootwayTunnelVertexShaderBindings,
          FootwayTunnelFragmentShaderBindings
        > {
  FootwayTunnelRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: FootwayTunnelVertexShaderBindings(shaderLibrary),
        fragment: FootwayTunnelFragmentShaderBindings(shaderLibrary),
        ubos: [
          FootwayTunnelUbo(
            vertexShader: shaderLibrary['footway_tunnel_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['footway_tunnel_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['footway_tunnel_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['footway_tunnel_vert']!,
            fragmentShader: shaderLibrary['footway_tunnel_frag']!,
          ),
        ],
      );

  late final FootwayTunnelUbo footwayTunnelUbo = ubos[0] as FootwayTunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 footwayTunnelUboWidthStops,
    required Vector2 footwayTunnelUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    footwayTunnelUbo.set(
      widthStops: footwayTunnelUboWidthStops,
      dasharraySize: footwayTunnelUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `pier`
class PierVertexShaderBindings extends VertexShaderBindings {
  PierVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['pier_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `pier`
class PierFragmentShaderBindings extends FragmentShaderBindings {
  PierFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['pier_frag']!);
}

/// Generated bindings for the render pipeline `pier`
class PierRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PierVertexShaderBindings,
          PierFragmentShaderBindings
        > {
  PierRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PierVertexShaderBindings(shaderLibrary),
        fragment: PierFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['pier_vert']!,
            fragmentShader: shaderLibrary['pier_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['pier_vert']!,
            fragmentShader: shaderLibrary['pier_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `pier_road`
class PierRoadVertexShaderBindings extends VertexShaderBindings {
  PierRoadVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['pier_road_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `pier_road`
class PierRoadFragmentShaderBindings extends FragmentShaderBindings {
  PierRoadFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['pier_road_frag']!);
}

/// Generated bindings for the render pipeline `pier_road`
class PierRoadRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PierRoadVertexShaderBindings,
          PierRoadFragmentShaderBindings
        > {
  PierRoadRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PierRoadVertexShaderBindings(shaderLibrary),
        fragment: PierRoadFragmentShaderBindings(shaderLibrary),
        ubos: [
          PierRoadUbo(
            vertexShader: shaderLibrary['pier_road_vert']!,
            fragmentShader: shaderLibrary['pier_road_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['pier_road_vert']!,
            fragmentShader: shaderLibrary['pier_road_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['pier_road_vert']!,
            fragmentShader: shaderLibrary['pier_road_frag']!,
          ),
        ],
        samplers: [],
      );

  late final PierRoadUbo pierRoadUbo = ubos[0] as PierRoadUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pierRoadUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    pierRoadUbo.set(widthStops: pierRoadUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `bridge`
class BridgeVertexShaderBindings extends VertexShaderBindings {
  BridgeVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['bridge_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `bridge`
class BridgeFragmentShaderBindings extends FragmentShaderBindings {
  BridgeFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['bridge_frag']!);
}

/// Generated bindings for the render pipeline `bridge`
class BridgeRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BridgeVertexShaderBindings,
          BridgeFragmentShaderBindings
        > {
  BridgeRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: BridgeVertexShaderBindings(shaderLibrary),
        fragment: BridgeFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['bridge_vert']!,
            fragmentShader: shaderLibrary['bridge_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['bridge_vert']!,
            fragmentShader: shaderLibrary['bridge_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `minor_road_outline`
class MinorRoadOutlineVertexShaderBindings extends VertexShaderBindings {
  MinorRoadOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibrary['minor_road_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_road_outline`
class MinorRoadOutlineFragmentShaderBindings extends FragmentShaderBindings {
  MinorRoadOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['minor_road_outline_frag']!);
}

/// Generated bindings for the render pipeline `minor_road_outline`
class MinorRoadOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRoadOutlineVertexShaderBindings,
          MinorRoadOutlineFragmentShaderBindings
        > {
  MinorRoadOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MinorRoadOutlineVertexShaderBindings(shaderLibrary),
        fragment: MinorRoadOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          MinorRoadOutlineUbo(
            vertexShader: shaderLibrary['minor_road_outline_vert']!,
            fragmentShader: shaderLibrary['minor_road_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['minor_road_outline_vert']!,
            fragmentShader: shaderLibrary['minor_road_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['minor_road_outline_vert']!,
            fragmentShader: shaderLibrary['minor_road_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MinorRoadOutlineUbo minorRoadOutlineUbo =
      ubos[0] as MinorRoadOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRoadOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    minorRoadOutlineUbo.set(widthStops: minorRoadOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `major_road_outline`
class MajorRoadOutlineVertexShaderBindings extends VertexShaderBindings {
  MajorRoadOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibrary['major_road_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_road_outline`
class MajorRoadOutlineFragmentShaderBindings extends FragmentShaderBindings {
  MajorRoadOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['major_road_outline_frag']!);
}

/// Generated bindings for the render pipeline `major_road_outline`
class MajorRoadOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRoadOutlineVertexShaderBindings,
          MajorRoadOutlineFragmentShaderBindings
        > {
  MajorRoadOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MajorRoadOutlineVertexShaderBindings(shaderLibrary),
        fragment: MajorRoadOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          MajorRoadOutlineUbo(
            vertexShader: shaderLibrary['major_road_outline_vert']!,
            fragmentShader: shaderLibrary['major_road_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['major_road_outline_vert']!,
            fragmentShader: shaderLibrary['major_road_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['major_road_outline_vert']!,
            fragmentShader: shaderLibrary['major_road_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MajorRoadOutlineUbo majorRoadOutlineUbo =
      ubos[0] as MajorRoadOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRoadOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    majorRoadOutlineUbo.set(widthStops: majorRoadOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `highway_outline`
class HighwayOutlineVertexShaderBindings extends VertexShaderBindings {
  HighwayOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['highway_outline_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `highway_outline`
class HighwayOutlineFragmentShaderBindings extends FragmentShaderBindings {
  HighwayOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['highway_outline_frag']!);
}

/// Generated bindings for the render pipeline `highway_outline`
class HighwayOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HighwayOutlineVertexShaderBindings,
          HighwayOutlineFragmentShaderBindings
        > {
  HighwayOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: HighwayOutlineVertexShaderBindings(shaderLibrary),
        fragment: HighwayOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          HighwayOutlineUbo(
            vertexShader: shaderLibrary['highway_outline_vert']!,
            fragmentShader: shaderLibrary['highway_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['highway_outline_vert']!,
            fragmentShader: shaderLibrary['highway_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['highway_outline_vert']!,
            fragmentShader: shaderLibrary['highway_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final HighwayOutlineUbo highwayOutlineUbo = ubos[0] as HighwayOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 highwayOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    highwayOutlineUbo.set(widthStops: highwayOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `road_under_construction`
class RoadUnderConstructionVertexShaderBindings extends VertexShaderBindings {
  RoadUnderConstructionVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 44,
        shader: shaderLibrary['road_under_construction_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 color,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, color);
    set_float(36, $setVertexData, widthStartValue);
    set_float(40, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `road_under_construction`
class RoadUnderConstructionFragmentShaderBindings
    extends FragmentShaderBindings {
  RoadUnderConstructionFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['road_under_construction_frag']!);
}

/// Generated bindings for the render pipeline `road_under_construction`
class RoadUnderConstructionRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RoadUnderConstructionVertexShaderBindings,
          RoadUnderConstructionFragmentShaderBindings
        > {
  RoadUnderConstructionRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: RoadUnderConstructionVertexShaderBindings(shaderLibrary),
        fragment: RoadUnderConstructionFragmentShaderBindings(shaderLibrary),
        ubos: [
          RoadUnderConstructionUbo(
            vertexShader: shaderLibrary['road_under_construction_vert']!,
            fragmentShader: shaderLibrary['road_under_construction_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['road_under_construction_vert']!,
            fragmentShader: shaderLibrary['road_under_construction_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['road_under_construction_vert']!,
            fragmentShader: shaderLibrary['road_under_construction_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['road_under_construction_vert']!,
            fragmentShader: shaderLibrary['road_under_construction_frag']!,
          ),
        ],
      );

  late final RoadUnderConstructionUbo roadUnderConstructionUbo =
      ubos[0] as RoadUnderConstructionUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 roadUnderConstructionUboWidthStops,
    required Vector2 roadUnderConstructionUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    roadUnderConstructionUbo.set(
      widthStops: roadUnderConstructionUboWidthStops,
      dasharraySize: roadUnderConstructionUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `minor_road`
class MinorRoadVertexShaderBindings extends VertexShaderBindings {
  MinorRoadVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['minor_road_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_road`
class MinorRoadFragmentShaderBindings extends FragmentShaderBindings {
  MinorRoadFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['minor_road_frag']!);
}

/// Generated bindings for the render pipeline `minor_road`
class MinorRoadRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRoadVertexShaderBindings,
          MinorRoadFragmentShaderBindings
        > {
  MinorRoadRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MinorRoadVertexShaderBindings(shaderLibrary),
        fragment: MinorRoadFragmentShaderBindings(shaderLibrary),
        ubos: [
          MinorRoadUbo(
            vertexShader: shaderLibrary['minor_road_vert']!,
            fragmentShader: shaderLibrary['minor_road_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['minor_road_vert']!,
            fragmentShader: shaderLibrary['minor_road_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['minor_road_vert']!,
            fragmentShader: shaderLibrary['minor_road_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MinorRoadUbo minorRoadUbo = ubos[0] as MinorRoadUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRoadUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    minorRoadUbo.set(widthStops: minorRoadUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `major_road`
class MajorRoadVertexShaderBindings extends VertexShaderBindings {
  MajorRoadVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 56, shader: shaderLibrary['major_road_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_vec4(16, $setVertexData, colorStartValue);
    set_vec4(32, $setVertexData, colorEndValue);
    set_float(48, $setVertexData, widthStartValue);
    set_float(52, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_road`
class MajorRoadFragmentShaderBindings extends FragmentShaderBindings {
  MajorRoadFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['major_road_frag']!);
}

/// Generated bindings for the render pipeline `major_road`
class MajorRoadRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRoadVertexShaderBindings,
          MajorRoadFragmentShaderBindings
        > {
  MajorRoadRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MajorRoadVertexShaderBindings(shaderLibrary),
        fragment: MajorRoadFragmentShaderBindings(shaderLibrary),
        ubos: [
          MajorRoadUbo(
            vertexShader: shaderLibrary['major_road_vert']!,
            fragmentShader: shaderLibrary['major_road_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['major_road_vert']!,
            fragmentShader: shaderLibrary['major_road_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['major_road_vert']!,
            fragmentShader: shaderLibrary['major_road_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MajorRoadUbo majorRoadUbo = ubos[0] as MajorRoadUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRoadUboColorStops,
    required Vector2 majorRoadUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    majorRoadUbo.set(
      colorStops: majorRoadUboColorStops,
      widthStops: majorRoadUboWidthStops,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `highway`
class HighwayVertexShaderBindings extends VertexShaderBindings {
  HighwayVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 56, shader: shaderLibrary['highway_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_vec4(16, $setVertexData, colorStartValue);
    set_vec4(32, $setVertexData, colorEndValue);
    set_float(48, $setVertexData, widthStartValue);
    set_float(52, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `highway`
class HighwayFragmentShaderBindings extends FragmentShaderBindings {
  HighwayFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['highway_frag']!);
}

/// Generated bindings for the render pipeline `highway`
class HighwayRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HighwayVertexShaderBindings,
          HighwayFragmentShaderBindings
        > {
  HighwayRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: HighwayVertexShaderBindings(shaderLibrary),
        fragment: HighwayFragmentShaderBindings(shaderLibrary),
        ubos: [
          HighwayUbo(
            vertexShader: shaderLibrary['highway_vert']!,
            fragmentShader: shaderLibrary['highway_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['highway_vert']!,
            fragmentShader: shaderLibrary['highway_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['highway_vert']!,
            fragmentShader: shaderLibrary['highway_frag']!,
          ),
        ],
        samplers: [],
      );

  late final HighwayUbo highwayUbo = ubos[0] as HighwayUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 highwayUboColorStops,
    required Vector2 highwayUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    highwayUbo.set(
      colorStops: highwayUboColorStops,
      widthStops: highwayUboWidthStops,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `path_outline`
class PathOutlineVertexShaderBindings extends VertexShaderBindings {
  PathOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['path_outline_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `path_outline`
class PathOutlineFragmentShaderBindings extends FragmentShaderBindings {
  PathOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['path_outline_frag']!);
}

/// Generated bindings for the render pipeline `path_outline`
class PathOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PathOutlineVertexShaderBindings,
          PathOutlineFragmentShaderBindings
        > {
  PathOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PathOutlineVertexShaderBindings(shaderLibrary),
        fragment: PathOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          PathOutlineUbo(
            vertexShader: shaderLibrary['path_outline_vert']!,
            fragmentShader: shaderLibrary['path_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['path_outline_vert']!,
            fragmentShader: shaderLibrary['path_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['path_outline_vert']!,
            fragmentShader: shaderLibrary['path_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final PathOutlineUbo pathOutlineUbo = ubos[0] as PathOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pathOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    pathOutlineUbo.set(widthStops: pathOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `path_minor`
class PathMinorVertexShaderBindings extends VertexShaderBindings {
  PathMinorVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['path_minor_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `path_minor`
class PathMinorFragmentShaderBindings extends FragmentShaderBindings {
  PathMinorFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['path_minor_frag']!);
}

/// Generated bindings for the render pipeline `path_minor`
class PathMinorRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PathMinorVertexShaderBindings,
          PathMinorFragmentShaderBindings
        > {
  PathMinorRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PathMinorVertexShaderBindings(shaderLibrary),
        fragment: PathMinorFragmentShaderBindings(shaderLibrary),
        ubos: [
          PathMinorUbo(
            vertexShader: shaderLibrary['path_minor_vert']!,
            fragmentShader: shaderLibrary['path_minor_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['path_minor_vert']!,
            fragmentShader: shaderLibrary['path_minor_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['path_minor_vert']!,
            fragmentShader: shaderLibrary['path_minor_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['path_minor_vert']!,
            fragmentShader: shaderLibrary['path_minor_frag']!,
          ),
        ],
      );

  late final PathMinorUbo pathMinorUbo = ubos[0] as PathMinorUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pathMinorUboWidthStops,
    required Vector2 pathMinorUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    pathMinorUbo.set(
      widthStops: pathMinorUboWidthStops,
      dasharraySize: pathMinorUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `path`
class PathVertexShaderBindings extends VertexShaderBindings {
  PathVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['path_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `path`
class PathFragmentShaderBindings extends FragmentShaderBindings {
  PathFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['path_frag']!);
}

/// Generated bindings for the render pipeline `path`
class PathRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PathVertexShaderBindings,
          PathFragmentShaderBindings
        > {
  PathRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PathVertexShaderBindings(shaderLibrary),
        fragment: PathFragmentShaderBindings(shaderLibrary),
        ubos: [
          PathUbo(
            vertexShader: shaderLibrary['path_vert']!,
            fragmentShader: shaderLibrary['path_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['path_vert']!,
            fragmentShader: shaderLibrary['path_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['path_vert']!,
            fragmentShader: shaderLibrary['path_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['path_vert']!,
            fragmentShader: shaderLibrary['path_frag']!,
          ),
        ],
      );

  late final PathUbo pathUbo = ubos[0] as PathUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pathUboWidthStops,
    required Vector2 pathUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    pathUbo.set(
      widthStops: pathUboWidthStops,
      dasharraySize: pathUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `major_rail`
class MajorRailVertexShaderBindings extends VertexShaderBindings {
  MajorRailVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 60, shader: shaderLibrary['major_rail_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double opacity,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_vec4(16, $setVertexData, colorStartValue);
    set_vec4(32, $setVertexData, colorEndValue);
    set_float(48, $setVertexData, opacity);
    set_float(52, $setVertexData, widthStartValue);
    set_float(56, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_rail`
class MajorRailFragmentShaderBindings extends FragmentShaderBindings {
  MajorRailFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['major_rail_frag']!);
}

/// Generated bindings for the render pipeline `major_rail`
class MajorRailRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRailVertexShaderBindings,
          MajorRailFragmentShaderBindings
        > {
  MajorRailRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MajorRailVertexShaderBindings(shaderLibrary),
        fragment: MajorRailFragmentShaderBindings(shaderLibrary),
        ubos: [
          MajorRailUbo(
            vertexShader: shaderLibrary['major_rail_vert']!,
            fragmentShader: shaderLibrary['major_rail_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['major_rail_vert']!,
            fragmentShader: shaderLibrary['major_rail_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['major_rail_vert']!,
            fragmentShader: shaderLibrary['major_rail_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MajorRailUbo majorRailUbo = ubos[0] as MajorRailUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRailUboColorStops,
    required Vector2 majorRailUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    majorRailUbo.set(
      colorStops: majorRailUboColorStops,
      widthStops: majorRailUboWidthStops,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `major_rail_hatching`
class MajorRailHatchingVertexShaderBindings extends VertexShaderBindings {
  MajorRailHatchingVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 64,
        shader: shaderLibrary['major_rail_hatching_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double opacity,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, colorStartValue);
    set_vec4(36, $setVertexData, colorEndValue);
    set_float(52, $setVertexData, opacity);
    set_float(56, $setVertexData, widthStartValue);
    set_float(60, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_rail_hatching`
class MajorRailHatchingFragmentShaderBindings extends FragmentShaderBindings {
  MajorRailHatchingFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['major_rail_hatching_frag']!);
}

/// Generated bindings for the render pipeline `major_rail_hatching`
class MajorRailHatchingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRailHatchingVertexShaderBindings,
          MajorRailHatchingFragmentShaderBindings
        > {
  MajorRailHatchingRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MajorRailHatchingVertexShaderBindings(shaderLibrary),
        fragment: MajorRailHatchingFragmentShaderBindings(shaderLibrary),
        ubos: [
          MajorRailHatchingUbo(
            vertexShader: shaderLibrary['major_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['major_rail_hatching_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['major_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['major_rail_hatching_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['major_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['major_rail_hatching_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['major_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['major_rail_hatching_frag']!,
          ),
        ],
      );

  late final MajorRailHatchingUbo majorRailHatchingUbo =
      ubos[0] as MajorRailHatchingUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRailHatchingUboColorStops,
    required Vector2 majorRailHatchingUboWidthStops,
    required Vector2 majorRailHatchingUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    majorRailHatchingUbo.set(
      colorStops: majorRailHatchingUboColorStops,
      widthStops: majorRailHatchingUboWidthStops,
      dasharraySize: majorRailHatchingUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `minor_rail`
class MinorRailVertexShaderBindings extends VertexShaderBindings {
  MinorRailVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['minor_rail_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_rail`
class MinorRailFragmentShaderBindings extends FragmentShaderBindings {
  MinorRailFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['minor_rail_frag']!);
}

/// Generated bindings for the render pipeline `minor_rail`
class MinorRailRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRailVertexShaderBindings,
          MinorRailFragmentShaderBindings
        > {
  MinorRailRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MinorRailVertexShaderBindings(shaderLibrary),
        fragment: MinorRailFragmentShaderBindings(shaderLibrary),
        ubos: [
          MinorRailUbo(
            vertexShader: shaderLibrary['minor_rail_vert']!,
            fragmentShader: shaderLibrary['minor_rail_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['minor_rail_vert']!,
            fragmentShader: shaderLibrary['minor_rail_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['minor_rail_vert']!,
            fragmentShader: shaderLibrary['minor_rail_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MinorRailUbo minorRailUbo = ubos[0] as MinorRailUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRailUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    minorRailUbo.set(widthStops: minorRailUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `minor_rail_hatching`
class MinorRailHatchingVertexShaderBindings extends VertexShaderBindings {
  MinorRailHatchingVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 28,
        shader: shaderLibrary['minor_rail_hatching_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_rail_hatching`
class MinorRailHatchingFragmentShaderBindings extends FragmentShaderBindings {
  MinorRailHatchingFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['minor_rail_hatching_frag']!);
}

/// Generated bindings for the render pipeline `minor_rail_hatching`
class MinorRailHatchingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRailHatchingVertexShaderBindings,
          MinorRailHatchingFragmentShaderBindings
        > {
  MinorRailHatchingRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MinorRailHatchingVertexShaderBindings(shaderLibrary),
        fragment: MinorRailHatchingFragmentShaderBindings(shaderLibrary),
        ubos: [
          MinorRailHatchingUbo(
            vertexShader: shaderLibrary['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['minor_rail_hatching_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['minor_rail_hatching_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['minor_rail_hatching_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibrary['minor_rail_hatching_frag']!,
          ),
        ],
      );

  late final MinorRailHatchingUbo minorRailHatchingUbo =
      ubos[0] as MinorRailHatchingUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRailHatchingUboWidthStops,
    required Vector2 minorRailHatchingUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    minorRailHatchingUbo.set(
      widthStops: minorRailHatchingUboWidthStops,
      dasharraySize: minorRailHatchingUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `building`
class BuildingVertexShaderBindings extends VertexShaderBindings {
  BuildingVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['building_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `building`
class BuildingFragmentShaderBindings extends FragmentShaderBindings {
  BuildingFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['building_frag']!);
}

/// Generated bindings for the render pipeline `building`
class BuildingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BuildingVertexShaderBindings,
          BuildingFragmentShaderBindings
        > {
  BuildingRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: BuildingVertexShaderBindings(shaderLibrary),
        fragment: BuildingFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(
            vertexShader: shaderLibrary['building_vert']!,
            fragmentShader: shaderLibrary['building_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['building_vert']!,
            fragmentShader: shaderLibrary['building_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `aqueduct_outline`
class AqueductOutlineVertexShaderBindings extends VertexShaderBindings {
  AqueductOutlineVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibrary['aqueduct_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `aqueduct_outline`
class AqueductOutlineFragmentShaderBindings extends FragmentShaderBindings {
  AqueductOutlineFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['aqueduct_outline_frag']!);
}

/// Generated bindings for the render pipeline `aqueduct_outline`
class AqueductOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AqueductOutlineVertexShaderBindings,
          AqueductOutlineFragmentShaderBindings
        > {
  AqueductOutlineRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: AqueductOutlineVertexShaderBindings(shaderLibrary),
        fragment: AqueductOutlineFragmentShaderBindings(shaderLibrary),
        ubos: [
          AqueductOutlineUbo(
            vertexShader: shaderLibrary['aqueduct_outline_vert']!,
            fragmentShader: shaderLibrary['aqueduct_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['aqueduct_outline_vert']!,
            fragmentShader: shaderLibrary['aqueduct_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['aqueduct_outline_vert']!,
            fragmentShader: shaderLibrary['aqueduct_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final AqueductOutlineUbo aqueductOutlineUbo =
      ubos[0] as AqueductOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 aqueductOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    aqueductOutlineUbo.set(widthStops: aqueductOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `aqueduct`
class AqueductVertexShaderBindings extends VertexShaderBindings {
  AqueductVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['aqueduct_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `aqueduct`
class AqueductFragmentShaderBindings extends FragmentShaderBindings {
  AqueductFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['aqueduct_frag']!);
}

/// Generated bindings for the render pipeline `aqueduct`
class AqueductRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AqueductVertexShaderBindings,
          AqueductFragmentShaderBindings
        > {
  AqueductRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: AqueductVertexShaderBindings(shaderLibrary),
        fragment: AqueductFragmentShaderBindings(shaderLibrary),
        ubos: [
          AqueductUbo(
            vertexShader: shaderLibrary['aqueduct_vert']!,
            fragmentShader: shaderLibrary['aqueduct_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['aqueduct_vert']!,
            fragmentShader: shaderLibrary['aqueduct_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['aqueduct_vert']!,
            fragmentShader: shaderLibrary['aqueduct_frag']!,
          ),
        ],
        samplers: [],
      );

  late final AqueductUbo aqueductUbo = ubos[0] as AqueductUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 aqueductUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    aqueductUbo.set(widthStops: aqueductUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `cablecar`
class CablecarVertexShaderBindings extends VertexShaderBindings {
  CablecarVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['cablecar_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `cablecar`
class CablecarFragmentShaderBindings extends FragmentShaderBindings {
  CablecarFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['cablecar_frag']!);
}

/// Generated bindings for the render pipeline `cablecar`
class CablecarRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CablecarVertexShaderBindings,
          CablecarFragmentShaderBindings
        > {
  CablecarRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CablecarVertexShaderBindings(shaderLibrary),
        fragment: CablecarFragmentShaderBindings(shaderLibrary),
        ubos: [
          CablecarUbo(
            vertexShader: shaderLibrary['cablecar_vert']!,
            fragmentShader: shaderLibrary['cablecar_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['cablecar_vert']!,
            fragmentShader: shaderLibrary['cablecar_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['cablecar_vert']!,
            fragmentShader: shaderLibrary['cablecar_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CablecarUbo cablecarUbo = ubos[0] as CablecarUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cablecarUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    cablecarUbo.set(widthStops: cablecarUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `cablecar_dash`
class CablecarDashVertexShaderBindings extends VertexShaderBindings {
  CablecarDashVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['cablecar_dash_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `cablecar_dash`
class CablecarDashFragmentShaderBindings extends FragmentShaderBindings {
  CablecarDashFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['cablecar_dash_frag']!);
}

/// Generated bindings for the render pipeline `cablecar_dash`
class CablecarDashRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CablecarDashVertexShaderBindings,
          CablecarDashFragmentShaderBindings
        > {
  CablecarDashRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CablecarDashVertexShaderBindings(shaderLibrary),
        fragment: CablecarDashFragmentShaderBindings(shaderLibrary),
        ubos: [
          CablecarDashUbo(
            vertexShader: shaderLibrary['cablecar_dash_vert']!,
            fragmentShader: shaderLibrary['cablecar_dash_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['cablecar_dash_vert']!,
            fragmentShader: shaderLibrary['cablecar_dash_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['cablecar_dash_vert']!,
            fragmentShader: shaderLibrary['cablecar_dash_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['cablecar_dash_vert']!,
            fragmentShader: shaderLibrary['cablecar_dash_frag']!,
          ),
        ],
      );

  late final CablecarDashUbo cablecarDashUbo = ubos[0] as CablecarDashUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cablecarDashUboWidthStops,
    required Vector2 cablecarDashUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    cablecarDashUbo.set(
      widthStops: cablecarDashUboWidthStops,
      dasharraySize: cablecarDashUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `other_border`
class OtherBorderVertexShaderBindings extends VertexShaderBindings {
  OtherBorderVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['other_border_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `other_border`
class OtherBorderFragmentShaderBindings extends FragmentShaderBindings {
  OtherBorderFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['other_border_frag']!);
}

/// Generated bindings for the render pipeline `other_border`
class OtherBorderRenderPipelineBindings
    extends
        RenderPipelineBindings<
          OtherBorderVertexShaderBindings,
          OtherBorderFragmentShaderBindings
        > {
  OtherBorderRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: OtherBorderVertexShaderBindings(shaderLibrary),
        fragment: OtherBorderFragmentShaderBindings(shaderLibrary),
        ubos: [
          OtherBorderUbo(
            vertexShader: shaderLibrary['other_border_vert']!,
            fragmentShader: shaderLibrary['other_border_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['other_border_vert']!,
            fragmentShader: shaderLibrary['other_border_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['other_border_vert']!,
            fragmentShader: shaderLibrary['other_border_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['other_border_vert']!,
            fragmentShader: shaderLibrary['other_border_frag']!,
          ),
        ],
      );

  late final OtherBorderUbo otherBorderUbo = ubos[0] as OtherBorderUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 otherBorderUboWidthStops,
    required Vector2 otherBorderUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    otherBorderUbo.set(
      widthStops: otherBorderUboWidthStops,
      dasharraySize: otherBorderUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `disputed_border`
class DisputedBorderVertexShaderBindings extends VertexShaderBindings {
  DisputedBorderVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 28, shader: shaderLibrary['disputed_border_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `disputed_border`
class DisputedBorderFragmentShaderBindings extends FragmentShaderBindings {
  DisputedBorderFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['disputed_border_frag']!);
}

/// Generated bindings for the render pipeline `disputed_border`
class DisputedBorderRenderPipelineBindings
    extends
        RenderPipelineBindings<
          DisputedBorderVertexShaderBindings,
          DisputedBorderFragmentShaderBindings
        > {
  DisputedBorderRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: DisputedBorderVertexShaderBindings(shaderLibrary),
        fragment: DisputedBorderFragmentShaderBindings(shaderLibrary),
        ubos: [
          DisputedBorderUbo(
            vertexShader: shaderLibrary['disputed_border_vert']!,
            fragmentShader: shaderLibrary['disputed_border_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['disputed_border_vert']!,
            fragmentShader: shaderLibrary['disputed_border_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['disputed_border_vert']!,
            fragmentShader: shaderLibrary['disputed_border_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibrary['disputed_border_vert']!,
            fragmentShader: shaderLibrary['disputed_border_frag']!,
          ),
        ],
      );

  late final DisputedBorderUbo disputedBorderUbo = ubos[0] as DisputedBorderUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 disputedBorderUboWidthStops,
    required Vector2 disputedBorderUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    disputedBorderUbo.set(
      widthStops: disputedBorderUboWidthStops,
      dasharraySize: disputedBorderUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `country_border`
class CountryBorderVertexShaderBindings extends VertexShaderBindings {
  CountryBorderVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 24, shader: shaderLibrary['country_border_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `country_border`
class CountryBorderFragmentShaderBindings extends FragmentShaderBindings {
  CountryBorderFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['country_border_frag']!);
}

/// Generated bindings for the render pipeline `country_border`
class CountryBorderRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CountryBorderVertexShaderBindings,
          CountryBorderFragmentShaderBindings
        > {
  CountryBorderRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CountryBorderVertexShaderBindings(shaderLibrary),
        fragment: CountryBorderFragmentShaderBindings(shaderLibrary),
        ubos: [
          CountryBorderUbo(
            vertexShader: shaderLibrary['country_border_vert']!,
            fragmentShader: shaderLibrary['country_border_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibrary['country_border_vert']!,
            fragmentShader: shaderLibrary['country_border_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibrary['country_border_vert']!,
            fragmentShader: shaderLibrary['country_border_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CountryBorderUbo countryBorderUbo = ubos[0] as CountryBorderUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 countryBorderUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    countryBorderUbo.set(widthStops: countryBorderUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}
