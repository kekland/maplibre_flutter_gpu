// GENERATED FILE - DO NOT MODIFY
// Generated by lib/src/style_precompiler_2/style_precompiler.dart

// ignore_for_file: unused_local_variable, non_constant_identifier_names, implementation_imports, duplicate_import, depend_on_referenced_packages

import 'package:gpu_vector_tile_renderer/_controller.dart';
import 'package:gpu_vector_tile_renderer/_renderer.dart';
import 'package:gpu_vector_tile_renderer/_utils.dart';
import 'package:gpu_vector_tile_renderer/_spec.dart' as spec;
import 'package:gpu_vector_tile_renderer/_vector_tile.dart' as vt;
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter_map/flutter_map.dart';

// GENERATED FILE - DO NOT MODIFY
// Generated by lib/src/shaders/bindings/shader_bindings_generator.dart

import 'package:gpu_vector_tile_renderer/_shaders.dart';
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:vector_math/vector_math_64.dart';

const shaderBundleName = 'maptiler-streets-v2.shaderbundle';

/// Generated UBO bindings for `BackgroundUbo`
class BackgroundUbo extends UniformBufferObjectBindings {
  BackgroundUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'BackgroundUbo');

  void set({required Vector4 color}) {
    if (slot == null) return;

    set_vec4(get_member_offset(slot!, 'color'), $setData, color);

    setInternal();
  }
}

/// Generated UBO bindings for `Tile`
class TileUbo extends UniformBufferObjectBindings {
  TileUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'Tile');

  void set({
    required Matrix4 localToGl,
    required double size,
    required double extent,
    required double opacity,
  }) {
    if (slot == null) return;

    set_mat4(get_member_offset(slot!, 'local_to_gl'), $setData, localToGl);
    set_float(get_member_offset(slot!, 'size'), $setData, size);
    set_float(get_member_offset(slot!, 'extent'), $setData, extent);
    set_float(get_member_offset(slot!, 'opacity'), $setData, opacity);

    setInternal();
  }
}

/// Generated UBO bindings for `Camera`
class CameraUbo extends UniformBufferObjectBindings {
  CameraUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'Camera');

  void set({
    required Matrix4 worldToGl,
    required double zoom,
    required double pixelRatio,
  }) {
    if (slot == null) return;

    set_mat4(get_member_offset(slot!, 'world_to_gl'), $setData, worldToGl);
    set_float(get_member_offset(slot!, 'zoom'), $setData, zoom);
    set_float(get_member_offset(slot!, 'pixel_ratio'), $setData, pixelRatio);

    setInternal();
  }
}

/// Generated UBO bindings for `MeadowUbo`
class MeadowUbo extends UniformBufferObjectBindings {
  MeadowUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MeadowUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `ScrubUbo`
class ScrubUbo extends UniformBufferObjectBindings {
  ScrubUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'ScrubUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CropUbo`
class CropUbo extends UniformBufferObjectBindings {
  CropUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CropUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `GlacierUbo`
class GlacierUbo extends UniformBufferObjectBindings {
  GlacierUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'GlacierUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `ForestUbo`
class ForestUbo extends UniformBufferObjectBindings {
  ForestUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'ForestUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `ResidentialUbo`
class ResidentialUbo extends UniformBufferObjectBindings {
  ResidentialUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'ResidentialUbo');

  void set({required Vector2 colorStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);

    setInternal();
  }
}

/// Generated UBO bindings for `IndustrialUbo`
class IndustrialUbo extends UniformBufferObjectBindings {
  IndustrialUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'IndustrialUbo');

  void set({required Vector2 opacityStops, required Vector2 colorStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);
    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CemeteryUbo`
class CemeteryUbo extends UniformBufferObjectBindings {
  CemeteryUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CemeteryUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `HospitalUbo`
class HospitalUbo extends UniformBufferObjectBindings {
  HospitalUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'HospitalUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `StadiumUbo`
class StadiumUbo extends UniformBufferObjectBindings {
  StadiumUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'StadiumUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `SchoolUbo`
class SchoolUbo extends UniformBufferObjectBindings {
  SchoolUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'SchoolUbo');

  void set({required Vector2 opacityStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RiverTunnelUbo`
class RiverTunnelUbo extends UniformBufferObjectBindings {
  RiverTunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'RiverTunnelUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `RiverUbo`
class RiverUbo extends UniformBufferObjectBindings {
  RiverUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'RiverUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `AerowayUbo`
class AerowayUbo extends UniformBufferObjectBindings {
  AerowayUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'AerowayUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `FerryLineUbo`
class FerryLineUbo extends UniformBufferObjectBindings {
  FerryLineUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'FerryLineUbo');

  void set({
    required Vector2 colorStops,
    required Vector2 opacityStops,
    required Vector2 widthStops,
    required Vector2 dasharraySize,
  }) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'opacity_stops'), $setData, opacityStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `TunnelOutlineUbo`
class TunnelOutlineUbo extends UniformBufferObjectBindings {
  TunnelOutlineUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'TunnelOutlineUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `TunnelUbo`
class TunnelUbo extends UniformBufferObjectBindings {
  TunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'TunnelUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RailwayTunnelUbo`
class RailwayTunnelUbo extends UniformBufferObjectBindings {
  RailwayTunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'RailwayTunnelUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RailwayTunnelHatchingUbo`
class RailwayTunnelHatchingUbo extends UniformBufferObjectBindings {
  RailwayTunnelHatchingUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'RailwayTunnelHatchingUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `FootwayTunnelOutlineUbo`
class FootwayTunnelOutlineUbo extends UniformBufferObjectBindings {
  FootwayTunnelOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'FootwayTunnelOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `FootwayTunnelUbo`
class FootwayTunnelUbo extends UniformBufferObjectBindings {
  FootwayTunnelUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'FootwayTunnelUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `PierRoadUbo`
class PierRoadUbo extends UniformBufferObjectBindings {
  PierRoadUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PierRoadUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRoadOutlineUbo`
class MinorRoadOutlineUbo extends UniformBufferObjectBindings {
  MinorRoadOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MinorRoadOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRoadOutlineUbo`
class MajorRoadOutlineUbo extends UniformBufferObjectBindings {
  MajorRoadOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MajorRoadOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `HighwayOutlineUbo`
class HighwayOutlineUbo extends UniformBufferObjectBindings {
  HighwayOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'HighwayOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `RoadUnderConstructionUbo`
class RoadUnderConstructionUbo extends UniformBufferObjectBindings {
  RoadUnderConstructionUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'RoadUnderConstructionUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRoadUbo`
class MinorRoadUbo extends UniformBufferObjectBindings {
  MinorRoadUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MinorRoadUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRoadUbo`
class MajorRoadUbo extends UniformBufferObjectBindings {
  MajorRoadUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MajorRoadUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `HighwayUbo`
class HighwayUbo extends UniformBufferObjectBindings {
  HighwayUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'HighwayUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `PathOutlineUbo`
class PathOutlineUbo extends UniformBufferObjectBindings {
  PathOutlineUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PathOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `PathUbo`
class PathUbo extends UniformBufferObjectBindings {
  PathUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'PathUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRailUbo`
class MajorRailUbo extends UniformBufferObjectBindings {
  MajorRailUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MajorRailUbo');

  void set({required Vector2 colorStops, required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'color_stops'), $setData, colorStops);
    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MajorRailHatchingUbo`
class MajorRailHatchingUbo extends UniformBufferObjectBindings {
  MajorRailHatchingUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MajorRailHatchingUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRailUbo`
class MinorRailUbo extends UniformBufferObjectBindings {
  MinorRailUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'MinorRailUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `MinorRailHatchingUbo`
class MinorRailHatchingUbo extends UniformBufferObjectBindings {
  MinorRailHatchingUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'MinorRailHatchingUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `AqueductOutlineUbo`
class AqueductOutlineUbo extends UniformBufferObjectBindings {
  AqueductOutlineUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'AqueductOutlineUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `AqueductUbo`
class AqueductUbo extends UniformBufferObjectBindings {
  AqueductUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'AqueductUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CablecarUbo`
class CablecarUbo extends UniformBufferObjectBindings {
  CablecarUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CablecarUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated UBO bindings for `CablecarDashUbo`
class CablecarDashUbo extends UniformBufferObjectBindings {
  CablecarDashUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CablecarDashUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `OtherBorderUbo`
class OtherBorderUbo extends UniformBufferObjectBindings {
  OtherBorderUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'OtherBorderUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `DisputedBorderUbo`
class DisputedBorderUbo extends UniformBufferObjectBindings {
  DisputedBorderUbo({
    required super.vertexShader,
    required super.fragmentShader,
  }) : super(name: 'DisputedBorderUbo');

  void set({required Vector2 widthStops, required Vector2 dasharraySize}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);
    set_vec2(
      get_member_offset(slot!, 'dasharray_size'),
      $setData,
      dasharraySize,
    );

    setInternal();
  }
}

/// Generated UBO bindings for `CountryBorderUbo`
class CountryBorderUbo extends UniformBufferObjectBindings {
  CountryBorderUbo({required super.vertexShader, required super.fragmentShader})
    : super(name: 'CountryBorderUbo');

  void set({required Vector2 widthStops}) {
    if (slot == null) return;

    set_vec2(get_member_offset(slot!, 'width_stops'), $setData, widthStops);

    setInternal();
  }
}

/// Generated bindings for the vertex shader `background`
class BackgroundVertexShaderBindings extends VertexShaderBindings {
  BackgroundVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 8,
        shader: shaderLibraryProvider['background_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `background`
class BackgroundFragmentShaderBindings extends FragmentShaderBindings {
  BackgroundFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['background_frag']!);
}

/// Generated bindings for the render pipeline `background`
class BackgroundRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BackgroundVertexShaderBindings,
          BackgroundFragmentShaderBindings
        > {
  BackgroundRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: BackgroundVertexShaderBindings(shaderLibraryProvider),
        fragment: BackgroundFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          BackgroundUbo(
            vertexShader: shaderLibraryProvider['background_vert']!,
            fragmentShader: shaderLibraryProvider['background_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['background_vert']!,
            fragmentShader: shaderLibraryProvider['background_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['background_vert']!,
            fragmentShader: shaderLibraryProvider['background_frag']!,
          ),
        ],
        samplers: [],
      );

  late final BackgroundUbo backgroundUbo = ubos[0] as BackgroundUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector4 backgroundUboColor,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    backgroundUbo.set(color: backgroundUboColor);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `meadow`
class MeadowVertexShaderBindings extends VertexShaderBindings {
  MeadowVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['meadow_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `meadow`
class MeadowFragmentShaderBindings extends FragmentShaderBindings {
  MeadowFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['meadow_frag']!);
}

/// Generated bindings for the render pipeline `meadow`
class MeadowRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MeadowVertexShaderBindings,
          MeadowFragmentShaderBindings
        > {
  MeadowRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: MeadowVertexShaderBindings(shaderLibraryProvider),
        fragment: MeadowFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MeadowUbo(
            vertexShader: shaderLibraryProvider['meadow_vert']!,
            fragmentShader: shaderLibraryProvider['meadow_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['meadow_vert']!,
            fragmentShader: shaderLibraryProvider['meadow_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['meadow_vert']!,
            fragmentShader: shaderLibraryProvider['meadow_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MeadowUbo meadowUbo = ubos[0] as MeadowUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 meadowUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    meadowUbo.set(opacityStops: meadowUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `scrub`
class ScrubVertexShaderBindings extends VertexShaderBindings {
  ScrubVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['scrub_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `scrub`
class ScrubFragmentShaderBindings extends FragmentShaderBindings {
  ScrubFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['scrub_frag']!);
}

/// Generated bindings for the render pipeline `scrub`
class ScrubRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ScrubVertexShaderBindings,
          ScrubFragmentShaderBindings
        > {
  ScrubRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: ScrubVertexShaderBindings(shaderLibraryProvider),
        fragment: ScrubFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          ScrubUbo(
            vertexShader: shaderLibraryProvider['scrub_vert']!,
            fragmentShader: shaderLibraryProvider['scrub_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['scrub_vert']!,
            fragmentShader: shaderLibraryProvider['scrub_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['scrub_vert']!,
            fragmentShader: shaderLibraryProvider['scrub_frag']!,
          ),
        ],
        samplers: [],
      );

  late final ScrubUbo scrubUbo = ubos[0] as ScrubUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 scrubUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    scrubUbo.set(opacityStops: scrubUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `crop`
class CropVertexShaderBindings extends VertexShaderBindings {
  CropVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['crop_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `crop`
class CropFragmentShaderBindings extends FragmentShaderBindings {
  CropFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['crop_frag']!);
}

/// Generated bindings for the render pipeline `crop`
class CropRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CropVertexShaderBindings,
          CropFragmentShaderBindings
        > {
  CropRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: CropVertexShaderBindings(shaderLibraryProvider),
        fragment: CropFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          CropUbo(
            vertexShader: shaderLibraryProvider['crop_vert']!,
            fragmentShader: shaderLibraryProvider['crop_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['crop_vert']!,
            fragmentShader: shaderLibraryProvider['crop_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['crop_vert']!,
            fragmentShader: shaderLibraryProvider['crop_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CropUbo cropUbo = ubos[0] as CropUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cropUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    cropUbo.set(opacityStops: cropUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `glacier`
class GlacierVertexShaderBindings extends VertexShaderBindings {
  GlacierVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['glacier_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `glacier`
class GlacierFragmentShaderBindings extends FragmentShaderBindings {
  GlacierFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['glacier_frag']!);
}

/// Generated bindings for the render pipeline `glacier`
class GlacierRenderPipelineBindings
    extends
        RenderPipelineBindings<
          GlacierVertexShaderBindings,
          GlacierFragmentShaderBindings
        > {
  GlacierRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: GlacierVertexShaderBindings(shaderLibraryProvider),
        fragment: GlacierFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          GlacierUbo(
            vertexShader: shaderLibraryProvider['glacier_vert']!,
            fragmentShader: shaderLibraryProvider['glacier_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['glacier_vert']!,
            fragmentShader: shaderLibraryProvider['glacier_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['glacier_vert']!,
            fragmentShader: shaderLibraryProvider['glacier_frag']!,
          ),
        ],
        samplers: [],
      );

  late final GlacierUbo glacierUbo = ubos[0] as GlacierUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 glacierUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    glacierUbo.set(opacityStops: glacierUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `forest`
class ForestVertexShaderBindings extends VertexShaderBindings {
  ForestVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['forest_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `forest`
class ForestFragmentShaderBindings extends FragmentShaderBindings {
  ForestFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['forest_frag']!);
}

/// Generated bindings for the render pipeline `forest`
class ForestRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ForestVertexShaderBindings,
          ForestFragmentShaderBindings
        > {
  ForestRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: ForestVertexShaderBindings(shaderLibraryProvider),
        fragment: ForestFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          ForestUbo(
            vertexShader: shaderLibraryProvider['forest_vert']!,
            fragmentShader: shaderLibraryProvider['forest_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['forest_vert']!,
            fragmentShader: shaderLibraryProvider['forest_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['forest_vert']!,
            fragmentShader: shaderLibraryProvider['forest_frag']!,
          ),
        ],
        samplers: [],
      );

  late final ForestUbo forestUbo = ubos[0] as ForestUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 forestUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    forestUbo.set(opacityStops: forestUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `sand`
class SandVertexShaderBindings extends VertexShaderBindings {
  SandVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['sand_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `sand`
class SandFragmentShaderBindings extends FragmentShaderBindings {
  SandFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['sand_frag']!);
}

/// Generated bindings for the render pipeline `sand`
class SandRenderPipelineBindings
    extends
        RenderPipelineBindings<
          SandVertexShaderBindings,
          SandFragmentShaderBindings
        > {
  SandRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: SandVertexShaderBindings(shaderLibraryProvider),
        fragment: SandFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['sand_vert']!,
            fragmentShader: shaderLibraryProvider['sand_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['sand_vert']!,
            fragmentShader: shaderLibraryProvider['sand_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `wood`
class WoodVertexShaderBindings extends VertexShaderBindings {
  WoodVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['wood_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `wood`
class WoodFragmentShaderBindings extends FragmentShaderBindings {
  WoodFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['wood_frag']!);
}

/// Generated bindings for the render pipeline `wood`
class WoodRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WoodVertexShaderBindings,
          WoodFragmentShaderBindings
        > {
  WoodRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: WoodVertexShaderBindings(shaderLibraryProvider),
        fragment: WoodFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['wood_vert']!,
            fragmentShader: shaderLibraryProvider['wood_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['wood_vert']!,
            fragmentShader: shaderLibraryProvider['wood_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `residential`
class ResidentialVertexShaderBindings extends VertexShaderBindings {
  ResidentialVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 40,
        shader: shaderLibraryProvider['residential_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec4(8, $setVertexData, colorStartValue);
    set_vec4(24, $setVertexData, colorEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `residential`
class ResidentialFragmentShaderBindings extends FragmentShaderBindings {
  ResidentialFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['residential_frag']!);
}

/// Generated bindings for the render pipeline `residential`
class ResidentialRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ResidentialVertexShaderBindings,
          ResidentialFragmentShaderBindings
        > {
  ResidentialRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: ResidentialVertexShaderBindings(shaderLibraryProvider),
        fragment: ResidentialFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          ResidentialUbo(
            vertexShader: shaderLibraryProvider['residential_vert']!,
            fragmentShader: shaderLibraryProvider['residential_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['residential_vert']!,
            fragmentShader: shaderLibraryProvider['residential_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['residential_vert']!,
            fragmentShader: shaderLibraryProvider['residential_frag']!,
          ),
        ],
        samplers: [],
      );

  late final ResidentialUbo residentialUbo = ubos[0] as ResidentialUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 residentialUboColorStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    residentialUbo.set(colorStops: residentialUboColorStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `industrial`
class IndustrialVertexShaderBindings extends VertexShaderBindings {
  IndustrialVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 48,
        shader: shaderLibraryProvider['industrial_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);
    set_vec4(16, $setVertexData, colorStartValue);
    set_vec4(32, $setVertexData, colorEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `industrial`
class IndustrialFragmentShaderBindings extends FragmentShaderBindings {
  IndustrialFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['industrial_frag']!);
}

/// Generated bindings for the render pipeline `industrial`
class IndustrialRenderPipelineBindings
    extends
        RenderPipelineBindings<
          IndustrialVertexShaderBindings,
          IndustrialFragmentShaderBindings
        > {
  IndustrialRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: IndustrialVertexShaderBindings(shaderLibraryProvider),
        fragment: IndustrialFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          IndustrialUbo(
            vertexShader: shaderLibraryProvider['industrial_vert']!,
            fragmentShader: shaderLibraryProvider['industrial_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['industrial_vert']!,
            fragmentShader: shaderLibraryProvider['industrial_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['industrial_vert']!,
            fragmentShader: shaderLibraryProvider['industrial_frag']!,
          ),
        ],
        samplers: [],
      );

  late final IndustrialUbo industrialUbo = ubos[0] as IndustrialUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 industrialUboOpacityStops,
    required Vector2 industrialUboColorStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    industrialUbo.set(
      opacityStops: industrialUboOpacityStops,
      colorStops: industrialUboColorStops,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `grass`
class GrassVertexShaderBindings extends VertexShaderBindings {
  GrassVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['grass_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `grass`
class GrassFragmentShaderBindings extends FragmentShaderBindings {
  GrassFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['grass_frag']!);
}

/// Generated bindings for the render pipeline `grass`
class GrassRenderPipelineBindings
    extends
        RenderPipelineBindings<
          GrassVertexShaderBindings,
          GrassFragmentShaderBindings
        > {
  GrassRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: GrassVertexShaderBindings(shaderLibraryProvider),
        fragment: GrassFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['grass_vert']!,
            fragmentShader: shaderLibraryProvider['grass_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['grass_vert']!,
            fragmentShader: shaderLibraryProvider['grass_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `airport_zone`
class AirportZoneVertexShaderBindings extends VertexShaderBindings {
  AirportZoneVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 8,
        shader: shaderLibraryProvider['airport_zone_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `airport_zone`
class AirportZoneFragmentShaderBindings extends FragmentShaderBindings {
  AirportZoneFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['airport_zone_frag']!);
}

/// Generated bindings for the render pipeline `airport_zone`
class AirportZoneRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AirportZoneVertexShaderBindings,
          AirportZoneFragmentShaderBindings
        > {
  AirportZoneRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: AirportZoneVertexShaderBindings(shaderLibraryProvider),
        fragment: AirportZoneFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['airport_zone_vert']!,
            fragmentShader: shaderLibraryProvider['airport_zone_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['airport_zone_vert']!,
            fragmentShader: shaderLibraryProvider['airport_zone_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `pedestrian`
class PedestrianVertexShaderBindings extends VertexShaderBindings {
  PedestrianVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 8,
        shader: shaderLibraryProvider['pedestrian_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `pedestrian`
class PedestrianFragmentShaderBindings extends FragmentShaderBindings {
  PedestrianFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['pedestrian_frag']!);
}

/// Generated bindings for the render pipeline `pedestrian`
class PedestrianRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PedestrianVertexShaderBindings,
          PedestrianFragmentShaderBindings
        > {
  PedestrianRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: PedestrianVertexShaderBindings(shaderLibraryProvider),
        fragment: PedestrianFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['pedestrian_vert']!,
            fragmentShader: shaderLibraryProvider['pedestrian_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['pedestrian_vert']!,
            fragmentShader: shaderLibraryProvider['pedestrian_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `cemetery`
class CemeteryVertexShaderBindings extends VertexShaderBindings {
  CemeteryVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 16,
        shader: shaderLibraryProvider['cemetery_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `cemetery`
class CemeteryFragmentShaderBindings extends FragmentShaderBindings {
  CemeteryFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['cemetery_frag']!);
}

/// Generated bindings for the render pipeline `cemetery`
class CemeteryRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CemeteryVertexShaderBindings,
          CemeteryFragmentShaderBindings
        > {
  CemeteryRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: CemeteryVertexShaderBindings(shaderLibraryProvider),
        fragment: CemeteryFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          CemeteryUbo(
            vertexShader: shaderLibraryProvider['cemetery_vert']!,
            fragmentShader: shaderLibraryProvider['cemetery_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['cemetery_vert']!,
            fragmentShader: shaderLibraryProvider['cemetery_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['cemetery_vert']!,
            fragmentShader: shaderLibraryProvider['cemetery_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CemeteryUbo cemeteryUbo = ubos[0] as CemeteryUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cemeteryUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    cemeteryUbo.set(opacityStops: cemeteryUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `hospital`
class HospitalVertexShaderBindings extends VertexShaderBindings {
  HospitalVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 16,
        shader: shaderLibraryProvider['hospital_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `hospital`
class HospitalFragmentShaderBindings extends FragmentShaderBindings {
  HospitalFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['hospital_frag']!);
}

/// Generated bindings for the render pipeline `hospital`
class HospitalRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HospitalVertexShaderBindings,
          HospitalFragmentShaderBindings
        > {
  HospitalRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: HospitalVertexShaderBindings(shaderLibraryProvider),
        fragment: HospitalFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          HospitalUbo(
            vertexShader: shaderLibraryProvider['hospital_vert']!,
            fragmentShader: shaderLibraryProvider['hospital_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['hospital_vert']!,
            fragmentShader: shaderLibraryProvider['hospital_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['hospital_vert']!,
            fragmentShader: shaderLibraryProvider['hospital_frag']!,
          ),
        ],
        samplers: [],
      );

  late final HospitalUbo hospitalUbo = ubos[0] as HospitalUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 hospitalUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    hospitalUbo.set(opacityStops: hospitalUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `stadium`
class StadiumVertexShaderBindings extends VertexShaderBindings {
  StadiumVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['stadium_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `stadium`
class StadiumFragmentShaderBindings extends FragmentShaderBindings {
  StadiumFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['stadium_frag']!);
}

/// Generated bindings for the render pipeline `stadium`
class StadiumRenderPipelineBindings
    extends
        RenderPipelineBindings<
          StadiumVertexShaderBindings,
          StadiumFragmentShaderBindings
        > {
  StadiumRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: StadiumVertexShaderBindings(shaderLibraryProvider),
        fragment: StadiumFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          StadiumUbo(
            vertexShader: shaderLibraryProvider['stadium_vert']!,
            fragmentShader: shaderLibraryProvider['stadium_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['stadium_vert']!,
            fragmentShader: shaderLibraryProvider['stadium_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['stadium_vert']!,
            fragmentShader: shaderLibraryProvider['stadium_frag']!,
          ),
        ],
        samplers: [],
      );

  late final StadiumUbo stadiumUbo = ubos[0] as StadiumUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 stadiumUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    stadiumUbo.set(opacityStops: stadiumUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `school`
class SchoolVertexShaderBindings extends VertexShaderBindings {
  SchoolVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 16, shader: shaderLibraryProvider['school_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacityStartValue);
    set_float(12, $setVertexData, opacityEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `school`
class SchoolFragmentShaderBindings extends FragmentShaderBindings {
  SchoolFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['school_frag']!);
}

/// Generated bindings for the render pipeline `school`
class SchoolRenderPipelineBindings
    extends
        RenderPipelineBindings<
          SchoolVertexShaderBindings,
          SchoolFragmentShaderBindings
        > {
  SchoolRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: SchoolVertexShaderBindings(shaderLibraryProvider),
        fragment: SchoolFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          SchoolUbo(
            vertexShader: shaderLibraryProvider['school_vert']!,
            fragmentShader: shaderLibraryProvider['school_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['school_vert']!,
            fragmentShader: shaderLibraryProvider['school_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['school_vert']!,
            fragmentShader: shaderLibraryProvider['school_frag']!,
          ),
        ],
        samplers: [],
      );

  late final SchoolUbo schoolUbo = ubos[0] as SchoolUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 schoolUboOpacityStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    schoolUbo.set(opacityStops: schoolUboOpacityStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `river_tunnel`
class RiverTunnelVertexShaderBindings extends VertexShaderBindings {
  RiverTunnelVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['river_tunnel_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `river_tunnel`
class RiverTunnelFragmentShaderBindings extends FragmentShaderBindings {
  RiverTunnelFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['river_tunnel_frag']!);
}

/// Generated bindings for the render pipeline `river_tunnel`
class RiverTunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RiverTunnelVertexShaderBindings,
          RiverTunnelFragmentShaderBindings
        > {
  RiverTunnelRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: RiverTunnelVertexShaderBindings(shaderLibraryProvider),
        fragment: RiverTunnelFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          RiverTunnelUbo(
            vertexShader: shaderLibraryProvider['river_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['river_tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['river_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['river_tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['river_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['river_tunnel_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['river_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['river_tunnel_frag']!,
          ),
        ],
      );

  late final RiverTunnelUbo riverTunnelUbo = ubos[0] as RiverTunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 riverTunnelUboWidthStops,
    required Vector2 riverTunnelUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    riverTunnelUbo.set(
      widthStops: riverTunnelUboWidthStops,
      dasharraySize: riverTunnelUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `river`
class RiverVertexShaderBindings extends VertexShaderBindings {
  RiverVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 24, shader: shaderLibraryProvider['river_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `river`
class RiverFragmentShaderBindings extends FragmentShaderBindings {
  RiverFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['river_frag']!);
}

/// Generated bindings for the render pipeline `river`
class RiverRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RiverVertexShaderBindings,
          RiverFragmentShaderBindings
        > {
  RiverRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: RiverVertexShaderBindings(shaderLibraryProvider),
        fragment: RiverFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          RiverUbo(
            vertexShader: shaderLibraryProvider['river_vert']!,
            fragmentShader: shaderLibraryProvider['river_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['river_vert']!,
            fragmentShader: shaderLibraryProvider['river_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['river_vert']!,
            fragmentShader: shaderLibraryProvider['river_frag']!,
          ),
        ],
        samplers: [],
      );

  late final RiverUbo riverUbo = ubos[0] as RiverUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 riverUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    riverUbo.set(widthStops: riverUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `water_intermittent`
class WaterIntermittentVertexShaderBindings extends VertexShaderBindings {
  WaterIntermittentVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 8,
        shader: shaderLibraryProvider['water_intermittent_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `water_intermittent`
class WaterIntermittentFragmentShaderBindings extends FragmentShaderBindings {
  WaterIntermittentFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['water_intermittent_frag']!);
}

/// Generated bindings for the render pipeline `water_intermittent`
class WaterIntermittentRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WaterIntermittentVertexShaderBindings,
          WaterIntermittentFragmentShaderBindings
        > {
  WaterIntermittentRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: WaterIntermittentVertexShaderBindings(shaderLibraryProvider),
        fragment: WaterIntermittentFragmentShaderBindings(
          shaderLibraryProvider,
        ),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['water_intermittent_vert']!,
            fragmentShader: shaderLibraryProvider['water_intermittent_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['water_intermittent_vert']!,
            fragmentShader: shaderLibraryProvider['water_intermittent_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `water`
class WaterVertexShaderBindings extends VertexShaderBindings {
  WaterVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 12, shader: shaderLibraryProvider['water_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacity,
  }) {
    set_vec2(0, $setVertexData, position);
    set_float(8, $setVertexData, opacity);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `water`
class WaterFragmentShaderBindings extends FragmentShaderBindings {
  WaterFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['water_frag']!);
}

/// Generated bindings for the render pipeline `water`
class WaterRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WaterVertexShaderBindings,
          WaterFragmentShaderBindings
        > {
  WaterRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: WaterVertexShaderBindings(shaderLibraryProvider),
        fragment: WaterFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['water_vert']!,
            fragmentShader: shaderLibraryProvider['water_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['water_vert']!,
            fragmentShader: shaderLibraryProvider['water_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `aeroway`
class AerowayVertexShaderBindings extends VertexShaderBindings {
  AerowayVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 24, shader: shaderLibraryProvider['aeroway_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `aeroway`
class AerowayFragmentShaderBindings extends FragmentShaderBindings {
  AerowayFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['aeroway_frag']!);
}

/// Generated bindings for the render pipeline `aeroway`
class AerowayRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AerowayVertexShaderBindings,
          AerowayFragmentShaderBindings
        > {
  AerowayRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: AerowayVertexShaderBindings(shaderLibraryProvider),
        fragment: AerowayFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          AerowayUbo(
            vertexShader: shaderLibraryProvider['aeroway_vert']!,
            fragmentShader: shaderLibraryProvider['aeroway_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['aeroway_vert']!,
            fragmentShader: shaderLibraryProvider['aeroway_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['aeroway_vert']!,
            fragmentShader: shaderLibraryProvider['aeroway_frag']!,
          ),
        ],
        samplers: [],
      );

  late final AerowayUbo aerowayUbo = ubos[0] as AerowayUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 aerowayUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    aerowayUbo.set(widthStops: aerowayUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `heliport`
class HeliportVertexShaderBindings extends VertexShaderBindings {
  HeliportVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['heliport_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `heliport`
class HeliportFragmentShaderBindings extends FragmentShaderBindings {
  HeliportFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['heliport_frag']!);
}

/// Generated bindings for the render pipeline `heliport`
class HeliportRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HeliportVertexShaderBindings,
          HeliportFragmentShaderBindings
        > {
  HeliportRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: HeliportVertexShaderBindings(shaderLibraryProvider),
        fragment: HeliportFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['heliport_vert']!,
            fragmentShader: shaderLibraryProvider['heliport_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['heliport_vert']!,
            fragmentShader: shaderLibraryProvider['heliport_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `ferry_line`
class FerryLineVertexShaderBindings extends VertexShaderBindings {
  FerryLineVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 68,
        shader: shaderLibraryProvider['ferry_line_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double opacityStartValue,
    required double opacityEndValue,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, colorStartValue);
    set_vec4(36, $setVertexData, colorEndValue);
    set_float(52, $setVertexData, opacityStartValue);
    set_float(56, $setVertexData, opacityEndValue);
    set_float(60, $setVertexData, widthStartValue);
    set_float(64, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `ferry_line`
class FerryLineFragmentShaderBindings extends FragmentShaderBindings {
  FerryLineFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['ferry_line_frag']!);
}

/// Generated bindings for the render pipeline `ferry_line`
class FerryLineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          FerryLineVertexShaderBindings,
          FerryLineFragmentShaderBindings
        > {
  FerryLineRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: FerryLineVertexShaderBindings(shaderLibraryProvider),
        fragment: FerryLineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          FerryLineUbo(
            vertexShader: shaderLibraryProvider['ferry_line_vert']!,
            fragmentShader: shaderLibraryProvider['ferry_line_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['ferry_line_vert']!,
            fragmentShader: shaderLibraryProvider['ferry_line_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['ferry_line_vert']!,
            fragmentShader: shaderLibraryProvider['ferry_line_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['ferry_line_vert']!,
            fragmentShader: shaderLibraryProvider['ferry_line_frag']!,
          ),
        ],
      );

  late final FerryLineUbo ferryLineUbo = ubos[0] as FerryLineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 ferryLineUboColorStops,
    required Vector2 ferryLineUboOpacityStops,
    required Vector2 ferryLineUboWidthStops,
    required Vector2 ferryLineUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    ferryLineUbo.set(
      colorStops: ferryLineUboColorStops,
      opacityStops: ferryLineUboOpacityStops,
      widthStops: ferryLineUboWidthStops,
      dasharraySize: ferryLineUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `tunnel_outline`
class TunnelOutlineVertexShaderBindings extends VertexShaderBindings {
  TunnelOutlineVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 44,
        shader: shaderLibraryProvider['tunnel_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 color,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, color);
    set_float(36, $setVertexData, widthStartValue);
    set_float(40, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `tunnel_outline`
class TunnelOutlineFragmentShaderBindings extends FragmentShaderBindings {
  TunnelOutlineFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['tunnel_outline_frag']!);
}

/// Generated bindings for the render pipeline `tunnel_outline`
class TunnelOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          TunnelOutlineVertexShaderBindings,
          TunnelOutlineFragmentShaderBindings
        > {
  TunnelOutlineRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: TunnelOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: TunnelOutlineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TunnelOutlineUbo(
            vertexShader: shaderLibraryProvider['tunnel_outline_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['tunnel_outline_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['tunnel_outline_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_outline_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['tunnel_outline_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_outline_frag']!,
          ),
        ],
      );

  late final TunnelOutlineUbo tunnelOutlineUbo = ubos[0] as TunnelOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 tunnelOutlineUboWidthStops,
    required Vector2 tunnelOutlineUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    tunnelOutlineUbo.set(
      widthStops: tunnelOutlineUboWidthStops,
      dasharraySize: tunnelOutlineUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `tunnel`
class TunnelVertexShaderBindings extends VertexShaderBindings {
  TunnelVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 40, shader: shaderLibraryProvider['tunnel_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required Vector4 color,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_vec4(16, $setVertexData, color);
    set_float(32, $setVertexData, widthStartValue);
    set_float(36, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `tunnel`
class TunnelFragmentShaderBindings extends FragmentShaderBindings {
  TunnelFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['tunnel_frag']!);
}

/// Generated bindings for the render pipeline `tunnel`
class TunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          TunnelVertexShaderBindings,
          TunnelFragmentShaderBindings
        > {
  TunnelRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: TunnelVertexShaderBindings(shaderLibraryProvider),
        fragment: TunnelFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TunnelUbo(
            vertexShader: shaderLibraryProvider['tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['tunnel_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TunnelUbo tunnelUbo = ubos[0] as TunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 tunnelUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tunnelUbo.set(widthStops: tunnelUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `railway_tunnel`
class RailwayTunnelVertexShaderBindings extends VertexShaderBindings {
  RailwayTunnelVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['railway_tunnel_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `railway_tunnel`
class RailwayTunnelFragmentShaderBindings extends FragmentShaderBindings {
  RailwayTunnelFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['railway_tunnel_frag']!);
}

/// Generated bindings for the render pipeline `railway_tunnel`
class RailwayTunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RailwayTunnelVertexShaderBindings,
          RailwayTunnelFragmentShaderBindings
        > {
  RailwayTunnelRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: RailwayTunnelVertexShaderBindings(shaderLibraryProvider),
        fragment: RailwayTunnelFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          RailwayTunnelUbo(
            vertexShader: shaderLibraryProvider['railway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['railway_tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['railway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['railway_tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['railway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['railway_tunnel_frag']!,
          ),
        ],
        samplers: [],
      );

  late final RailwayTunnelUbo railwayTunnelUbo = ubos[0] as RailwayTunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 railwayTunnelUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    railwayTunnelUbo.set(widthStops: railwayTunnelUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `railway_tunnel_hatching`
class RailwayTunnelHatchingVertexShaderBindings extends VertexShaderBindings {
  RailwayTunnelHatchingVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['railway_tunnel_hatching_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `railway_tunnel_hatching`
class RailwayTunnelHatchingFragmentShaderBindings
    extends FragmentShaderBindings {
  RailwayTunnelHatchingFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['railway_tunnel_hatching_frag']!);
}

/// Generated bindings for the render pipeline `railway_tunnel_hatching`
class RailwayTunnelHatchingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RailwayTunnelHatchingVertexShaderBindings,
          RailwayTunnelHatchingFragmentShaderBindings
        > {
  RailwayTunnelHatchingRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: RailwayTunnelHatchingVertexShaderBindings(
          shaderLibraryProvider,
        ),
        fragment: RailwayTunnelHatchingFragmentShaderBindings(
          shaderLibraryProvider,
        ),
        ubos: [
          RailwayTunnelHatchingUbo(
            vertexShader:
                shaderLibraryProvider['railway_tunnel_hatching_vert']!,
            fragmentShader:
                shaderLibraryProvider['railway_tunnel_hatching_frag']!,
          ),
          TileUbo(
            vertexShader:
                shaderLibraryProvider['railway_tunnel_hatching_vert']!,
            fragmentShader:
                shaderLibraryProvider['railway_tunnel_hatching_frag']!,
          ),
          CameraUbo(
            vertexShader:
                shaderLibraryProvider['railway_tunnel_hatching_vert']!,
            fragmentShader:
                shaderLibraryProvider['railway_tunnel_hatching_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader:
                shaderLibraryProvider['railway_tunnel_hatching_vert']!,
            fragmentShader:
                shaderLibraryProvider['railway_tunnel_hatching_frag']!,
          ),
        ],
      );

  late final RailwayTunnelHatchingUbo railwayTunnelHatchingUbo =
      ubos[0] as RailwayTunnelHatchingUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 railwayTunnelHatchingUboWidthStops,
    required Vector2 railwayTunnelHatchingUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    railwayTunnelHatchingUbo.set(
      widthStops: railwayTunnelHatchingUboWidthStops,
      dasharraySize: railwayTunnelHatchingUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `footway_tunnel_outline`
class FootwayTunnelOutlineVertexShaderBindings extends VertexShaderBindings {
  FootwayTunnelOutlineVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['footway_tunnel_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `footway_tunnel_outline`
class FootwayTunnelOutlineFragmentShaderBindings
    extends FragmentShaderBindings {
  FootwayTunnelOutlineFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['footway_tunnel_outline_frag']!);
}

/// Generated bindings for the render pipeline `footway_tunnel_outline`
class FootwayTunnelOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          FootwayTunnelOutlineVertexShaderBindings,
          FootwayTunnelOutlineFragmentShaderBindings
        > {
  FootwayTunnelOutlineRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: FootwayTunnelOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: FootwayTunnelOutlineFragmentShaderBindings(
          shaderLibraryProvider,
        ),
        ubos: [
          FootwayTunnelOutlineUbo(
            vertexShader: shaderLibraryProvider['footway_tunnel_outline_vert']!,
            fragmentShader:
                shaderLibraryProvider['footway_tunnel_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['footway_tunnel_outline_vert']!,
            fragmentShader:
                shaderLibraryProvider['footway_tunnel_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['footway_tunnel_outline_vert']!,
            fragmentShader:
                shaderLibraryProvider['footway_tunnel_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final FootwayTunnelOutlineUbo footwayTunnelOutlineUbo =
      ubos[0] as FootwayTunnelOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 footwayTunnelOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    footwayTunnelOutlineUbo.set(widthStops: footwayTunnelOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `footway_tunnel`
class FootwayTunnelVertexShaderBindings extends VertexShaderBindings {
  FootwayTunnelVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['footway_tunnel_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `footway_tunnel`
class FootwayTunnelFragmentShaderBindings extends FragmentShaderBindings {
  FootwayTunnelFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['footway_tunnel_frag']!);
}

/// Generated bindings for the render pipeline `footway_tunnel`
class FootwayTunnelRenderPipelineBindings
    extends
        RenderPipelineBindings<
          FootwayTunnelVertexShaderBindings,
          FootwayTunnelFragmentShaderBindings
        > {
  FootwayTunnelRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: FootwayTunnelVertexShaderBindings(shaderLibraryProvider),
        fragment: FootwayTunnelFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          FootwayTunnelUbo(
            vertexShader: shaderLibraryProvider['footway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['footway_tunnel_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['footway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['footway_tunnel_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['footway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['footway_tunnel_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['footway_tunnel_vert']!,
            fragmentShader: shaderLibraryProvider['footway_tunnel_frag']!,
          ),
        ],
      );

  late final FootwayTunnelUbo footwayTunnelUbo = ubos[0] as FootwayTunnelUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 footwayTunnelUboWidthStops,
    required Vector2 footwayTunnelUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    footwayTunnelUbo.set(
      widthStops: footwayTunnelUboWidthStops,
      dasharraySize: footwayTunnelUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `pier`
class PierVertexShaderBindings extends VertexShaderBindings {
  PierVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['pier_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `pier`
class PierFragmentShaderBindings extends FragmentShaderBindings {
  PierFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['pier_frag']!);
}

/// Generated bindings for the render pipeline `pier`
class PierRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PierVertexShaderBindings,
          PierFragmentShaderBindings
        > {
  PierRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: PierVertexShaderBindings(shaderLibraryProvider),
        fragment: PierFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['pier_vert']!,
            fragmentShader: shaderLibraryProvider['pier_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['pier_vert']!,
            fragmentShader: shaderLibraryProvider['pier_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `pier_road`
class PierRoadVertexShaderBindings extends VertexShaderBindings {
  PierRoadVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['pier_road_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `pier_road`
class PierRoadFragmentShaderBindings extends FragmentShaderBindings {
  PierRoadFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['pier_road_frag']!);
}

/// Generated bindings for the render pipeline `pier_road`
class PierRoadRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PierRoadVertexShaderBindings,
          PierRoadFragmentShaderBindings
        > {
  PierRoadRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: PierRoadVertexShaderBindings(shaderLibraryProvider),
        fragment: PierRoadFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          PierRoadUbo(
            vertexShader: shaderLibraryProvider['pier_road_vert']!,
            fragmentShader: shaderLibraryProvider['pier_road_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['pier_road_vert']!,
            fragmentShader: shaderLibraryProvider['pier_road_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['pier_road_vert']!,
            fragmentShader: shaderLibraryProvider['pier_road_frag']!,
          ),
        ],
        samplers: [],
      );

  late final PierRoadUbo pierRoadUbo = ubos[0] as PierRoadUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pierRoadUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    pierRoadUbo.set(widthStops: pierRoadUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `bridge`
class BridgeVertexShaderBindings extends VertexShaderBindings {
  BridgeVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['bridge_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `bridge`
class BridgeFragmentShaderBindings extends FragmentShaderBindings {
  BridgeFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['bridge_frag']!);
}

/// Generated bindings for the render pipeline `bridge`
class BridgeRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BridgeVertexShaderBindings,
          BridgeFragmentShaderBindings
        > {
  BridgeRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: BridgeVertexShaderBindings(shaderLibraryProvider),
        fragment: BridgeFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['bridge_vert']!,
            fragmentShader: shaderLibraryProvider['bridge_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['bridge_vert']!,
            fragmentShader: shaderLibraryProvider['bridge_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `minor_road_outline`
class MinorRoadOutlineVertexShaderBindings extends VertexShaderBindings {
  MinorRoadOutlineVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['minor_road_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_road_outline`
class MinorRoadOutlineFragmentShaderBindings extends FragmentShaderBindings {
  MinorRoadOutlineFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['minor_road_outline_frag']!);
}

/// Generated bindings for the render pipeline `minor_road_outline`
class MinorRoadOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRoadOutlineVertexShaderBindings,
          MinorRoadOutlineFragmentShaderBindings
        > {
  MinorRoadOutlineRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: MinorRoadOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: MinorRoadOutlineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MinorRoadOutlineUbo(
            vertexShader: shaderLibraryProvider['minor_road_outline_vert']!,
            fragmentShader: shaderLibraryProvider['minor_road_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['minor_road_outline_vert']!,
            fragmentShader: shaderLibraryProvider['minor_road_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['minor_road_outline_vert']!,
            fragmentShader: shaderLibraryProvider['minor_road_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MinorRoadOutlineUbo minorRoadOutlineUbo =
      ubos[0] as MinorRoadOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRoadOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    minorRoadOutlineUbo.set(widthStops: minorRoadOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `major_road_outline`
class MajorRoadOutlineVertexShaderBindings extends VertexShaderBindings {
  MajorRoadOutlineVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['major_road_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_road_outline`
class MajorRoadOutlineFragmentShaderBindings extends FragmentShaderBindings {
  MajorRoadOutlineFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['major_road_outline_frag']!);
}

/// Generated bindings for the render pipeline `major_road_outline`
class MajorRoadOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRoadOutlineVertexShaderBindings,
          MajorRoadOutlineFragmentShaderBindings
        > {
  MajorRoadOutlineRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: MajorRoadOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: MajorRoadOutlineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MajorRoadOutlineUbo(
            vertexShader: shaderLibraryProvider['major_road_outline_vert']!,
            fragmentShader: shaderLibraryProvider['major_road_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['major_road_outline_vert']!,
            fragmentShader: shaderLibraryProvider['major_road_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['major_road_outline_vert']!,
            fragmentShader: shaderLibraryProvider['major_road_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MajorRoadOutlineUbo majorRoadOutlineUbo =
      ubos[0] as MajorRoadOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRoadOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    majorRoadOutlineUbo.set(widthStops: majorRoadOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `highway_outline`
class HighwayOutlineVertexShaderBindings extends VertexShaderBindings {
  HighwayOutlineVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['highway_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `highway_outline`
class HighwayOutlineFragmentShaderBindings extends FragmentShaderBindings {
  HighwayOutlineFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['highway_outline_frag']!);
}

/// Generated bindings for the render pipeline `highway_outline`
class HighwayOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HighwayOutlineVertexShaderBindings,
          HighwayOutlineFragmentShaderBindings
        > {
  HighwayOutlineRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: HighwayOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: HighwayOutlineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          HighwayOutlineUbo(
            vertexShader: shaderLibraryProvider['highway_outline_vert']!,
            fragmentShader: shaderLibraryProvider['highway_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['highway_outline_vert']!,
            fragmentShader: shaderLibraryProvider['highway_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['highway_outline_vert']!,
            fragmentShader: shaderLibraryProvider['highway_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final HighwayOutlineUbo highwayOutlineUbo = ubos[0] as HighwayOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 highwayOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    highwayOutlineUbo.set(widthStops: highwayOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `road_under_construction`
class RoadUnderConstructionVertexShaderBindings extends VertexShaderBindings {
  RoadUnderConstructionVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 44,
        shader: shaderLibraryProvider['road_under_construction_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required Vector4 color,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_vec4(20, $setVertexData, color);
    set_float(36, $setVertexData, widthStartValue);
    set_float(40, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `road_under_construction`
class RoadUnderConstructionFragmentShaderBindings
    extends FragmentShaderBindings {
  RoadUnderConstructionFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['road_under_construction_frag']!);
}

/// Generated bindings for the render pipeline `road_under_construction`
class RoadUnderConstructionRenderPipelineBindings
    extends
        RenderPipelineBindings<
          RoadUnderConstructionVertexShaderBindings,
          RoadUnderConstructionFragmentShaderBindings
        > {
  RoadUnderConstructionRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: RoadUnderConstructionVertexShaderBindings(
          shaderLibraryProvider,
        ),
        fragment: RoadUnderConstructionFragmentShaderBindings(
          shaderLibraryProvider,
        ),
        ubos: [
          RoadUnderConstructionUbo(
            vertexShader:
                shaderLibraryProvider['road_under_construction_vert']!,
            fragmentShader:
                shaderLibraryProvider['road_under_construction_frag']!,
          ),
          TileUbo(
            vertexShader:
                shaderLibraryProvider['road_under_construction_vert']!,
            fragmentShader:
                shaderLibraryProvider['road_under_construction_frag']!,
          ),
          CameraUbo(
            vertexShader:
                shaderLibraryProvider['road_under_construction_vert']!,
            fragmentShader:
                shaderLibraryProvider['road_under_construction_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader:
                shaderLibraryProvider['road_under_construction_vert']!,
            fragmentShader:
                shaderLibraryProvider['road_under_construction_frag']!,
          ),
        ],
      );

  late final RoadUnderConstructionUbo roadUnderConstructionUbo =
      ubos[0] as RoadUnderConstructionUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 roadUnderConstructionUboWidthStops,
    required Vector2 roadUnderConstructionUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    roadUnderConstructionUbo.set(
      widthStops: roadUnderConstructionUboWidthStops,
      dasharraySize: roadUnderConstructionUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `minor_road`
class MinorRoadVertexShaderBindings extends VertexShaderBindings {
  MinorRoadVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['minor_road_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_road`
class MinorRoadFragmentShaderBindings extends FragmentShaderBindings {
  MinorRoadFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['minor_road_frag']!);
}

/// Generated bindings for the render pipeline `minor_road`
class MinorRoadRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRoadVertexShaderBindings,
          MinorRoadFragmentShaderBindings
        > {
  MinorRoadRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: MinorRoadVertexShaderBindings(shaderLibraryProvider),
        fragment: MinorRoadFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MinorRoadUbo(
            vertexShader: shaderLibraryProvider['minor_road_vert']!,
            fragmentShader: shaderLibraryProvider['minor_road_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['minor_road_vert']!,
            fragmentShader: shaderLibraryProvider['minor_road_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['minor_road_vert']!,
            fragmentShader: shaderLibraryProvider['minor_road_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MinorRoadUbo minorRoadUbo = ubos[0] as MinorRoadUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRoadUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    minorRoadUbo.set(widthStops: minorRoadUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `major_road`
class MajorRoadVertexShaderBindings extends VertexShaderBindings {
  MajorRoadVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['major_road_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_road`
class MajorRoadFragmentShaderBindings extends FragmentShaderBindings {
  MajorRoadFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['major_road_frag']!);
}

/// Generated bindings for the render pipeline `major_road`
class MajorRoadRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRoadVertexShaderBindings,
          MajorRoadFragmentShaderBindings
        > {
  MajorRoadRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: MajorRoadVertexShaderBindings(shaderLibraryProvider),
        fragment: MajorRoadFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MajorRoadUbo(
            vertexShader: shaderLibraryProvider['major_road_vert']!,
            fragmentShader: shaderLibraryProvider['major_road_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['major_road_vert']!,
            fragmentShader: shaderLibraryProvider['major_road_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['major_road_vert']!,
            fragmentShader: shaderLibraryProvider['major_road_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MajorRoadUbo majorRoadUbo = ubos[0] as MajorRoadUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRoadUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    majorRoadUbo.set(widthStops: majorRoadUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `highway`
class HighwayVertexShaderBindings extends VertexShaderBindings {
  HighwayVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 24, shader: shaderLibraryProvider['highway_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `highway`
class HighwayFragmentShaderBindings extends FragmentShaderBindings {
  HighwayFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['highway_frag']!);
}

/// Generated bindings for the render pipeline `highway`
class HighwayRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HighwayVertexShaderBindings,
          HighwayFragmentShaderBindings
        > {
  HighwayRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: HighwayVertexShaderBindings(shaderLibraryProvider),
        fragment: HighwayFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          HighwayUbo(
            vertexShader: shaderLibraryProvider['highway_vert']!,
            fragmentShader: shaderLibraryProvider['highway_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['highway_vert']!,
            fragmentShader: shaderLibraryProvider['highway_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['highway_vert']!,
            fragmentShader: shaderLibraryProvider['highway_frag']!,
          ),
        ],
        samplers: [],
      );

  late final HighwayUbo highwayUbo = ubos[0] as HighwayUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 highwayUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    highwayUbo.set(widthStops: highwayUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `path_outline`
class PathOutlineVertexShaderBindings extends VertexShaderBindings {
  PathOutlineVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['path_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `path_outline`
class PathOutlineFragmentShaderBindings extends FragmentShaderBindings {
  PathOutlineFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['path_outline_frag']!);
}

/// Generated bindings for the render pipeline `path_outline`
class PathOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PathOutlineVertexShaderBindings,
          PathOutlineFragmentShaderBindings
        > {
  PathOutlineRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: PathOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: PathOutlineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          PathOutlineUbo(
            vertexShader: shaderLibraryProvider['path_outline_vert']!,
            fragmentShader: shaderLibraryProvider['path_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['path_outline_vert']!,
            fragmentShader: shaderLibraryProvider['path_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['path_outline_vert']!,
            fragmentShader: shaderLibraryProvider['path_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final PathOutlineUbo pathOutlineUbo = ubos[0] as PathOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pathOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    pathOutlineUbo.set(widthStops: pathOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `path`
class PathVertexShaderBindings extends VertexShaderBindings {
  PathVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 28, shader: shaderLibraryProvider['path_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `path`
class PathFragmentShaderBindings extends FragmentShaderBindings {
  PathFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['path_frag']!);
}

/// Generated bindings for the render pipeline `path`
class PathRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PathVertexShaderBindings,
          PathFragmentShaderBindings
        > {
  PathRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: PathVertexShaderBindings(shaderLibraryProvider),
        fragment: PathFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          PathUbo(
            vertexShader: shaderLibraryProvider['path_vert']!,
            fragmentShader: shaderLibraryProvider['path_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['path_vert']!,
            fragmentShader: shaderLibraryProvider['path_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['path_vert']!,
            fragmentShader: shaderLibraryProvider['path_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['path_vert']!,
            fragmentShader: shaderLibraryProvider['path_frag']!,
          ),
        ],
      );

  late final PathUbo pathUbo = ubos[0] as PathUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 pathUboWidthStops,
    required Vector2 pathUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    pathUbo.set(
      widthStops: pathUboWidthStops,
      dasharraySize: pathUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `major_rail`
class MajorRailVertexShaderBindings extends VertexShaderBindings {
  MajorRailVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 60,
        shader: shaderLibraryProvider['major_rail_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
    required double opacity,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_vec4(16, $setVertexData, colorStartValue);
    set_vec4(32, $setVertexData, colorEndValue);
    set_float(48, $setVertexData, opacity);
    set_float(52, $setVertexData, widthStartValue);
    set_float(56, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_rail`
class MajorRailFragmentShaderBindings extends FragmentShaderBindings {
  MajorRailFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['major_rail_frag']!);
}

/// Generated bindings for the render pipeline `major_rail`
class MajorRailRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRailVertexShaderBindings,
          MajorRailFragmentShaderBindings
        > {
  MajorRailRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: MajorRailVertexShaderBindings(shaderLibraryProvider),
        fragment: MajorRailFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MajorRailUbo(
            vertexShader: shaderLibraryProvider['major_rail_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['major_rail_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['major_rail_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MajorRailUbo majorRailUbo = ubos[0] as MajorRailUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRailUboColorStops,
    required Vector2 majorRailUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    majorRailUbo.set(
      colorStops: majorRailUboColorStops,
      widthStops: majorRailUboWidthStops,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `major_rail_hatching`
class MajorRailHatchingVertexShaderBindings extends VertexShaderBindings {
  MajorRailHatchingVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 32,
        shader: shaderLibraryProvider['major_rail_hatching_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double opacity,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, opacity);
    set_float(24, $setVertexData, widthStartValue);
    set_float(28, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `major_rail_hatching`
class MajorRailHatchingFragmentShaderBindings extends FragmentShaderBindings {
  MajorRailHatchingFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['major_rail_hatching_frag']!);
}

/// Generated bindings for the render pipeline `major_rail_hatching`
class MajorRailHatchingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MajorRailHatchingVertexShaderBindings,
          MajorRailHatchingFragmentShaderBindings
        > {
  MajorRailHatchingRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: MajorRailHatchingVertexShaderBindings(shaderLibraryProvider),
        fragment: MajorRailHatchingFragmentShaderBindings(
          shaderLibraryProvider,
        ),
        ubos: [
          MajorRailHatchingUbo(
            vertexShader: shaderLibraryProvider['major_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_hatching_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['major_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_hatching_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['major_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_hatching_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['major_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['major_rail_hatching_frag']!,
          ),
        ],
      );

  late final MajorRailHatchingUbo majorRailHatchingUbo =
      ubos[0] as MajorRailHatchingUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 majorRailHatchingUboWidthStops,
    required Vector2 majorRailHatchingUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    majorRailHatchingUbo.set(
      widthStops: majorRailHatchingUboWidthStops,
      dasharraySize: majorRailHatchingUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `minor_rail`
class MinorRailVertexShaderBindings extends VertexShaderBindings {
  MinorRailVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['minor_rail_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_rail`
class MinorRailFragmentShaderBindings extends FragmentShaderBindings {
  MinorRailFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['minor_rail_frag']!);
}

/// Generated bindings for the render pipeline `minor_rail`
class MinorRailRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRailVertexShaderBindings,
          MinorRailFragmentShaderBindings
        > {
  MinorRailRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: MinorRailVertexShaderBindings(shaderLibraryProvider),
        fragment: MinorRailFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          MinorRailUbo(
            vertexShader: shaderLibraryProvider['minor_rail_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['minor_rail_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['minor_rail_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_frag']!,
          ),
        ],
        samplers: [],
      );

  late final MinorRailUbo minorRailUbo = ubos[0] as MinorRailUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRailUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    minorRailUbo.set(widthStops: minorRailUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `minor_rail_hatching`
class MinorRailHatchingVertexShaderBindings extends VertexShaderBindings {
  MinorRailHatchingVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['minor_rail_hatching_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `minor_rail_hatching`
class MinorRailHatchingFragmentShaderBindings extends FragmentShaderBindings {
  MinorRailHatchingFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['minor_rail_hatching_frag']!);
}

/// Generated bindings for the render pipeline `minor_rail_hatching`
class MinorRailHatchingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MinorRailHatchingVertexShaderBindings,
          MinorRailHatchingFragmentShaderBindings
        > {
  MinorRailHatchingRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: MinorRailHatchingVertexShaderBindings(shaderLibraryProvider),
        fragment: MinorRailHatchingFragmentShaderBindings(
          shaderLibraryProvider,
        ),
        ubos: [
          MinorRailHatchingUbo(
            vertexShader: shaderLibraryProvider['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_hatching_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_hatching_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_hatching_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['minor_rail_hatching_vert']!,
            fragmentShader: shaderLibraryProvider['minor_rail_hatching_frag']!,
          ),
        ],
      );

  late final MinorRailHatchingUbo minorRailHatchingUbo =
      ubos[0] as MinorRailHatchingUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 minorRailHatchingUboWidthStops,
    required Vector2 minorRailHatchingUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    minorRailHatchingUbo.set(
      widthStops: minorRailHatchingUboWidthStops,
      dasharraySize: minorRailHatchingUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `building`
class BuildingVertexShaderBindings extends VertexShaderBindings {
  BuildingVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(bytesPerVertex: 8, shader: shaderLibraryProvider['building_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    set_vec2(0, $setVertexData, position);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `building`
class BuildingFragmentShaderBindings extends FragmentShaderBindings {
  BuildingFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['building_frag']!);
}

/// Generated bindings for the render pipeline `building`
class BuildingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BuildingVertexShaderBindings,
          BuildingFragmentShaderBindings
        > {
  BuildingRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: BuildingVertexShaderBindings(shaderLibraryProvider),
        fragment: BuildingFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          TileUbo(
            vertexShader: shaderLibraryProvider['building_vert']!,
            fragmentShader: shaderLibraryProvider['building_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['building_vert']!,
            fragmentShader: shaderLibraryProvider['building_frag']!,
          ),
        ],
        samplers: [],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `aqueduct_outline`
class AqueductOutlineVertexShaderBindings extends VertexShaderBindings {
  AqueductOutlineVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['aqueduct_outline_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `aqueduct_outline`
class AqueductOutlineFragmentShaderBindings extends FragmentShaderBindings {
  AqueductOutlineFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['aqueduct_outline_frag']!);
}

/// Generated bindings for the render pipeline `aqueduct_outline`
class AqueductOutlineRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AqueductOutlineVertexShaderBindings,
          AqueductOutlineFragmentShaderBindings
        > {
  AqueductOutlineRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: AqueductOutlineVertexShaderBindings(shaderLibraryProvider),
        fragment: AqueductOutlineFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          AqueductOutlineUbo(
            vertexShader: shaderLibraryProvider['aqueduct_outline_vert']!,
            fragmentShader: shaderLibraryProvider['aqueduct_outline_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['aqueduct_outline_vert']!,
            fragmentShader: shaderLibraryProvider['aqueduct_outline_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['aqueduct_outline_vert']!,
            fragmentShader: shaderLibraryProvider['aqueduct_outline_frag']!,
          ),
        ],
        samplers: [],
      );

  late final AqueductOutlineUbo aqueductOutlineUbo =
      ubos[0] as AqueductOutlineUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 aqueductOutlineUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    aqueductOutlineUbo.set(widthStops: aqueductOutlineUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `aqueduct`
class AqueductVertexShaderBindings extends VertexShaderBindings {
  AqueductVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['aqueduct_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `aqueduct`
class AqueductFragmentShaderBindings extends FragmentShaderBindings {
  AqueductFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['aqueduct_frag']!);
}

/// Generated bindings for the render pipeline `aqueduct`
class AqueductRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AqueductVertexShaderBindings,
          AqueductFragmentShaderBindings
        > {
  AqueductRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: AqueductVertexShaderBindings(shaderLibraryProvider),
        fragment: AqueductFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          AqueductUbo(
            vertexShader: shaderLibraryProvider['aqueduct_vert']!,
            fragmentShader: shaderLibraryProvider['aqueduct_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['aqueduct_vert']!,
            fragmentShader: shaderLibraryProvider['aqueduct_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['aqueduct_vert']!,
            fragmentShader: shaderLibraryProvider['aqueduct_frag']!,
          ),
        ],
        samplers: [],
      );

  late final AqueductUbo aqueductUbo = ubos[0] as AqueductUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 aqueductUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    aqueductUbo.set(widthStops: aqueductUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `cablecar`
class CablecarVertexShaderBindings extends VertexShaderBindings {
  CablecarVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['cablecar_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `cablecar`
class CablecarFragmentShaderBindings extends FragmentShaderBindings {
  CablecarFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['cablecar_frag']!);
}

/// Generated bindings for the render pipeline `cablecar`
class CablecarRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CablecarVertexShaderBindings,
          CablecarFragmentShaderBindings
        > {
  CablecarRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: CablecarVertexShaderBindings(shaderLibraryProvider),
        fragment: CablecarFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          CablecarUbo(
            vertexShader: shaderLibraryProvider['cablecar_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['cablecar_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['cablecar_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CablecarUbo cablecarUbo = ubos[0] as CablecarUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cablecarUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    cablecarUbo.set(widthStops: cablecarUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

/// Generated bindings for the vertex shader `cablecar_dash`
class CablecarDashVertexShaderBindings extends VertexShaderBindings {
  CablecarDashVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['cablecar_dash_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `cablecar_dash`
class CablecarDashFragmentShaderBindings extends FragmentShaderBindings {
  CablecarDashFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['cablecar_dash_frag']!);
}

/// Generated bindings for the render pipeline `cablecar_dash`
class CablecarDashRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CablecarDashVertexShaderBindings,
          CablecarDashFragmentShaderBindings
        > {
  CablecarDashRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: CablecarDashVertexShaderBindings(shaderLibraryProvider),
        fragment: CablecarDashFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          CablecarDashUbo(
            vertexShader: shaderLibraryProvider['cablecar_dash_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_dash_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['cablecar_dash_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_dash_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['cablecar_dash_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_dash_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['cablecar_dash_vert']!,
            fragmentShader: shaderLibraryProvider['cablecar_dash_frag']!,
          ),
        ],
      );

  late final CablecarDashUbo cablecarDashUbo = ubos[0] as CablecarDashUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 cablecarDashUboWidthStops,
    required Vector2 cablecarDashUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    cablecarDashUbo.set(
      widthStops: cablecarDashUboWidthStops,
      dasharraySize: cablecarDashUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `other_border`
class OtherBorderVertexShaderBindings extends VertexShaderBindings {
  OtherBorderVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['other_border_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `other_border`
class OtherBorderFragmentShaderBindings extends FragmentShaderBindings {
  OtherBorderFragmentShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(shader: shaderLibraryProvider['other_border_frag']!);
}

/// Generated bindings for the render pipeline `other_border`
class OtherBorderRenderPipelineBindings
    extends
        RenderPipelineBindings<
          OtherBorderVertexShaderBindings,
          OtherBorderFragmentShaderBindings
        > {
  OtherBorderRenderPipelineBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        vertex: OtherBorderVertexShaderBindings(shaderLibraryProvider),
        fragment: OtherBorderFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          OtherBorderUbo(
            vertexShader: shaderLibraryProvider['other_border_vert']!,
            fragmentShader: shaderLibraryProvider['other_border_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['other_border_vert']!,
            fragmentShader: shaderLibraryProvider['other_border_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['other_border_vert']!,
            fragmentShader: shaderLibraryProvider['other_border_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['other_border_vert']!,
            fragmentShader: shaderLibraryProvider['other_border_frag']!,
          ),
        ],
      );

  late final OtherBorderUbo otherBorderUbo = ubos[0] as OtherBorderUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 otherBorderUboWidthStops,
    required Vector2 otherBorderUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    otherBorderUbo.set(
      widthStops: otherBorderUboWidthStops,
      dasharraySize: otherBorderUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `disputed_border`
class DisputedBorderVertexShaderBindings extends VertexShaderBindings {
  DisputedBorderVertexShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        bytesPerVertex: 28,
        shader: shaderLibraryProvider['disputed_border_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double lineLength,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, lineLength);
    set_float(20, $setVertexData, widthStartValue);
    set_float(24, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `disputed_border`
class DisputedBorderFragmentShaderBindings extends FragmentShaderBindings {
  DisputedBorderFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['disputed_border_frag']!);
}

/// Generated bindings for the render pipeline `disputed_border`
class DisputedBorderRenderPipelineBindings
    extends
        RenderPipelineBindings<
          DisputedBorderVertexShaderBindings,
          DisputedBorderFragmentShaderBindings
        > {
  DisputedBorderRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: DisputedBorderVertexShaderBindings(shaderLibraryProvider),
        fragment: DisputedBorderFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          DisputedBorderUbo(
            vertexShader: shaderLibraryProvider['disputed_border_vert']!,
            fragmentShader: shaderLibraryProvider['disputed_border_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['disputed_border_vert']!,
            fragmentShader: shaderLibraryProvider['disputed_border_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['disputed_border_vert']!,
            fragmentShader: shaderLibraryProvider['disputed_border_frag']!,
          ),
        ],
        samplers: [
          UniformSamplerBindings(
            name: 'dasharray',
            vertexShader: shaderLibraryProvider['disputed_border_vert']!,
            fragmentShader: shaderLibraryProvider['disputed_border_frag']!,
          ),
        ],
      );

  late final DisputedBorderUbo disputedBorderUbo = ubos[0] as DisputedBorderUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  late final UniformSamplerBindings dasharray = samplers[0];

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 disputedBorderUboWidthStops,
    required Vector2 disputedBorderUboDasharraySize,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
    required gpu.Texture dasharrayTexture,
    gpu.SamplerOptions? dasharrayTextureSamplerOptions,
  }) {
    disputedBorderUbo.set(
      widthStops: disputedBorderUboWidthStops,
      dasharraySize: disputedBorderUboDasharraySize,
    );
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
    dasharray.setTexture(
      dasharrayTexture,
      options: dasharrayTextureSamplerOptions,
    );
  }
}

/// Generated bindings for the vertex shader `country_border`
class CountryBorderVertexShaderBindings extends VertexShaderBindings {
  CountryBorderVertexShaderBindings(ShaderLibraryProvider shaderLibraryProvider)
    : super(
        bytesPerVertex: 24,
        shader: shaderLibraryProvider['country_border_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector2 normal,
    required double widthStartValue,
    required double widthEndValue,
  }) {
    set_vec2(0, $setVertexData, position);
    set_vec2(8, $setVertexData, normal);
    set_float(16, $setVertexData, widthStartValue);
    set_float(20, $setVertexData, widthEndValue);

    setVertexInternal(index);
  }
}

/// Generated bindings for the fragment shader `country_border`
class CountryBorderFragmentShaderBindings extends FragmentShaderBindings {
  CountryBorderFragmentShaderBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(shader: shaderLibraryProvider['country_border_frag']!);
}

/// Generated bindings for the render pipeline `country_border`
class CountryBorderRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CountryBorderVertexShaderBindings,
          CountryBorderFragmentShaderBindings
        > {
  CountryBorderRenderPipelineBindings(
    ShaderLibraryProvider shaderLibraryProvider,
  ) : super(
        vertex: CountryBorderVertexShaderBindings(shaderLibraryProvider),
        fragment: CountryBorderFragmentShaderBindings(shaderLibraryProvider),
        ubos: [
          CountryBorderUbo(
            vertexShader: shaderLibraryProvider['country_border_vert']!,
            fragmentShader: shaderLibraryProvider['country_border_frag']!,
          ),
          TileUbo(
            vertexShader: shaderLibraryProvider['country_border_vert']!,
            fragmentShader: shaderLibraryProvider['country_border_frag']!,
          ),
          CameraUbo(
            vertexShader: shaderLibraryProvider['country_border_vert']!,
            fragmentShader: shaderLibraryProvider['country_border_frag']!,
          ),
        ],
        samplers: [],
      );

  late final CountryBorderUbo countryBorderUbo = ubos[0] as CountryBorderUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the uniforms for this shader.
  void setUniforms({
    required Vector2 countryBorderUboWidthStops,
    required Matrix4 tileLocalToGl,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
    required double cameraPixelRatio,
  }) {
    countryBorderUbo.set(widthStops: countryBorderUboWidthStops);
    tileUbo.set(
      localToGl: tileLocalToGl,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(
      worldToGl: cameraWorldToGl,
      zoom: cameraZoom,
      pixelRatio: cameraPixelRatio,
    );
  }
}

SingleTileLayerRenderer? createSingleTileLayerRenderer(
  ShaderLibraryProvider shaderLibraryProvider,
  TileCoordinates coordinates,
  TileContainer container,
  spec.Layer specLayer,
  vt.Layer vtLayer,
) {
  return switch (specLayer.id) {
    'Background' => BackgroundLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Meadow' => MeadowLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Scrub' => ScrubLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Crop' => CropLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Glacier' => GlacierLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Forest' => ForestLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Sand' => SandLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Wood' => WoodLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Residential' => ResidentialLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Industrial' => IndustrialLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Grass' => GrassLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Airport zone' => AirportZoneLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Pedestrian' => PedestrianLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Cemetery' => CemeteryLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Hospital' => HospitalLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Stadium' => StadiumLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'School' => SchoolLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'River tunnel' => RiverTunnelLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'River' => RiverLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Water intermittent' => WaterIntermittentLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Water' => WaterLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Aeroway' => AerowayLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Heliport' => HeliportLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Ferry line' => FerryLineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Tunnel outline' => TunnelOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Tunnel' => TunnelLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Railway tunnel' => RailwayTunnelLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Railway tunnel hatching' => RailwayTunnelHatchingLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Footway tunnel outline' => FootwayTunnelOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Footway tunnel' => FootwayTunnelLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Pier' => PierLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Pier road' => PierRoadLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Bridge' => BridgeLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor road outline' => MinorRoadOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major road outline' => MajorRoadOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Highway outline' => HighwayOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Road under construction' => RoadUnderConstructionLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor road' => MinorRoadLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major road' => MajorRoadLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Highway' => HighwayLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Path outline' => PathOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Path' => PathLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major rail' => MajorRailLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Major rail hatching' => MajorRailHatchingLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor rail' => MinorRailLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Minor rail hatching' => MinorRailHatchingLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Building' => BuildingLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Aqueduct outline' => AqueductOutlineLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Aqueduct' => AqueductLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Cablecar' => CablecarLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Cablecar dash' => CablecarDashLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Other border' => OtherBorderLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Disputed border' => DisputedBorderLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    'Country border' => CountryBorderLayerRenderer(
      shaderLibraryProvider: shaderLibraryProvider,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as dynamic,
      vtLayer: vtLayer,
    ),
    _ => null,
  };
}

class BackgroundLayerRenderer extends $BackgroundLayerRenderer {
  BackgroundLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BackgroundRenderPipelineBindings(shaderLibraryProvider);

  @override
  final BackgroundRenderPipelineBindings pipeline;

  @override
  void setVertices() {
    final paint = specLayer.paint;

    pipeline.vertex.setVertex(0, position: Vector2(-1, -1));
    pipeline.vertex.setVertex(1, position: Vector2(1, -1));
    pipeline.vertex.setVertex(2, position: Vector2(1, 1));
    pipeline.vertex.setVertex(3, position: Vector2(-1, 1));

    pipeline.upload(gpu.gpuContext);
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color = paint.backgroundColor.evaluate(eval).vec;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      backgroundUboColor: color,
    );
  }
}

class MeadowLayerRenderer extends $FillLayerRenderer {
  MeadowLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MeadowRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MeadowRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      meadowUboOpacityStops: opacity_stops,
    );
  }
}

class ScrubLayerRenderer extends $FillLayerRenderer {
  ScrubLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ScrubRenderPipelineBindings(shaderLibraryProvider);

  @override
  final ScrubRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      scrubUboOpacityStops: opacity_stops,
    );
  }
}

class CropLayerRenderer extends $FillLayerRenderer {
  CropLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CropRenderPipelineBindings(shaderLibraryProvider);

  @override
  final CropRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cropUboOpacityStops: opacity_stops,
    );
  }
}

class GlacierLayerRenderer extends $FillLayerRenderer {
  GlacierLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = GlacierRenderPipelineBindings(shaderLibraryProvider);

  @override
  final GlacierRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [0.0, 10.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [0.0, 10.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [0.0, 10.0]),
      getNearestCeilValue(eval.zoom, const [0.0, 10.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      glacierUboOpacityStops: opacity_stops,
    );
  }
}

class ForestLayerRenderer extends $FillLayerRenderer {
  ForestLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ForestRenderPipelineBindings(shaderLibraryProvider);

  @override
  final ForestRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [1.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [1.0, 8.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [1.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [1.0, 8.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      forestUboOpacityStops: opacity_stops,
    );
  }
}

class SandLayerRenderer extends $FillLayerRenderer {
  SandLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = SandRenderPipelineBindings(shaderLibraryProvider);

  @override
  final SandRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class WoodLayerRenderer extends $FillLayerRenderer {
  WoodLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WoodRenderPipelineBindings(shaderLibraryProvider);

  @override
  final WoodRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class ResidentialLayerRenderer extends $FillLayerRenderer {
  ResidentialLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ResidentialRenderPipelineBindings(shaderLibraryProvider);

  @override
  final ResidentialRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [4.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [4.0, 16.0]),
              ),
            )
            .vec;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          colorStartValue: color_start_value,
          colorEndValue: color_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [4.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [4.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      residentialUboColorStops: color_stops,
    );
  }
}

class IndustrialLayerRenderer extends $FillLayerRenderer {
  IndustrialLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = IndustrialRenderPipelineBindings(shaderLibraryProvider);

  @override
  final IndustrialRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 10.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 10.0]),
              ),
            )
            .toDouble();
    final color_start_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .vec;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
          colorStartValue: color_start_value,
          colorEndValue: color_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 10.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 10.0]),
    );
    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      industrialUboOpacityStops: opacity_stops,
      industrialUboColorStops: color_stops,
    );
  }
}

class GrassLayerRenderer extends $FillLayerRenderer {
  GrassLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = GrassRenderPipelineBindings(shaderLibraryProvider);

  @override
  final GrassRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AirportZoneLayerRenderer extends $FillLayerRenderer {
  AirportZoneLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AirportZoneRenderPipelineBindings(shaderLibraryProvider);

  @override
  final AirportZoneRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class PedestrianLayerRenderer extends $FillLayerRenderer {
  PedestrianLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PedestrianRenderPipelineBindings(shaderLibraryProvider);

  @override
  final PedestrianRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class CemeteryLayerRenderer extends $FillLayerRenderer {
  CemeteryLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CemeteryRenderPipelineBindings(shaderLibraryProvider);

  @override
  final CemeteryRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cemeteryUboOpacityStops: opacity_stops,
    );
  }
}

class HospitalLayerRenderer extends $FillLayerRenderer {
  HospitalLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HospitalRenderPipelineBindings(shaderLibraryProvider);

  @override
  final HospitalRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      hospitalUboOpacityStops: opacity_stops,
    );
  }
}

class StadiumLayerRenderer extends $FillLayerRenderer {
  StadiumLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = StadiumRenderPipelineBindings(shaderLibraryProvider);

  @override
  final StadiumRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      stadiumUboOpacityStops: opacity_stops,
    );
  }
}

class SchoolLayerRenderer extends $FillLayerRenderer {
  SchoolLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = SchoolRenderPipelineBindings(shaderLibraryProvider);

  @override
  final SchoolRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
              ),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [9.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [9.0, 16.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      schoolUboOpacityStops: opacity_stops,
    );
  }
}

class RiverTunnelLayerRenderer extends $LineLayerRenderer {
  RiverTunnelLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RiverTunnelRenderPipelineBindings(shaderLibraryProvider);

  @override
  final RiverTunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      riverTunnelUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      riverTunnelUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class RiverLayerRenderer extends $LineLayerRenderer {
  RiverLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RiverRenderPipelineBindings(shaderLibraryProvider);

  @override
  final RiverRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      riverUboWidthStops: width_stops,
    );
  }
}

class WaterIntermittentLayerRenderer extends $FillLayerRenderer {
  WaterIntermittentLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WaterIntermittentRenderPipelineBindings(
         shaderLibraryProvider,
       );

  @override
  final WaterIntermittentRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class WaterLayerRenderer extends $FillLayerRenderer {
  WaterLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WaterRenderPipelineBindings(shaderLibraryProvider);

  @override
  final WaterRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity = paint.fillOpacity.evaluate(eval).toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacity: opacity,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AerowayLayerRenderer extends $LineLayerRenderer {
  AerowayLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AerowayRenderPipelineBindings(shaderLibraryProvider);

  @override
  final AerowayRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [11.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [11.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [11.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [11.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      aerowayUboWidthStops: width_stops,
    );
  }
}

class HeliportLayerRenderer extends $FillLayerRenderer {
  HeliportLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HeliportRenderPipelineBindings(shaderLibraryProvider);

  @override
  final HeliportRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class FerryLineLayerRenderer extends $LineLayerRenderer {
  FerryLineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = FerryLineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final FerryLineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [10.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [10.0, 16.0]),
              ),
            )
            .vec;
    final opacity_start_value =
        paint.lineOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [6.0, 7.0, 8.0]),
              ),
            )
            .toDouble();
    final opacity_end_value =
        paint.lineOpacity
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [6.0, 7.0, 8.0]),
              ),
            )
            .toDouble();
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [10.0, 14.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [10.0, 14.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        opacityStartValue: opacity_start_value,
        opacityEndValue: opacity_end_value,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [10.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [10.0, 16.0]),
    );
    final opacity_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [6.0, 7.0, 8.0]),
      getNearestCeilValue(eval.zoom, const [6.0, 7.0, 8.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [10.0, 14.0]),
      getNearestCeilValue(eval.zoom, const [10.0, 14.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      ferryLineUboColorStops: color_stops,
      ferryLineUboOpacityStops: opacity_stops,
      ferryLineUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      ferryLineUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class TunnelOutlineLayerRenderer extends $LineLayerRenderer {
  TunnelOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = TunnelOutlineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final TunnelOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color = paint.lineColor.evaluate(eval).vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        color: color,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      tunnelOutlineUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      tunnelOutlineUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class TunnelLayerRenderer extends $LineLayerRenderer {
  TunnelLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = TunnelRenderPipelineBindings(shaderLibraryProvider);

  @override
  final TunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color = paint.lineColor.evaluate(eval).vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        color: color,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      tunnelUboWidthStops: width_stops,
    );
  }
}

class RailwayTunnelLayerRenderer extends $LineLayerRenderer {
  RailwayTunnelLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RailwayTunnelRenderPipelineBindings(shaderLibraryProvider);

  @override
  final RailwayTunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      railwayTunnelUboWidthStops: width_stops,
    );
  }
}

class RailwayTunnelHatchingLayerRenderer extends $LineLayerRenderer {
  RailwayTunnelHatchingLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RailwayTunnelHatchingRenderPipelineBindings(
         shaderLibraryProvider,
       );

  @override
  final RailwayTunnelHatchingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      railwayTunnelHatchingUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      railwayTunnelHatchingUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class FootwayTunnelOutlineLayerRenderer extends $LineLayerRenderer {
  FootwayTunnelOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = FootwayTunnelOutlineRenderPipelineBindings(
         shaderLibraryProvider,
       );

  @override
  final FootwayTunnelOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      footwayTunnelOutlineUboWidthStops: width_stops,
    );
  }
}

class FootwayTunnelLayerRenderer extends $LineLayerRenderer {
  FootwayTunnelLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = FootwayTunnelRenderPipelineBindings(shaderLibraryProvider);

  @override
  final FootwayTunnelRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      footwayTunnelUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      footwayTunnelUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class PierLayerRenderer extends $FillLayerRenderer {
  PierLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PierRenderPipelineBindings(shaderLibraryProvider);

  @override
  final PierRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class PierRoadLayerRenderer extends $LineLayerRenderer {
  PierRoadLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PierRoadRenderPipelineBindings(shaderLibraryProvider);

  @override
  final PierRoadRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [15.0, 17.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [15.0, 17.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [15.0, 17.0]),
      getNearestCeilValue(eval.zoom, const [15.0, 17.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pierRoadUboWidthStops: width_stops,
    );
  }
}

class BridgeLayerRenderer extends $FillLayerRenderer {
  BridgeLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BridgeRenderPipelineBindings(shaderLibraryProvider);

  @override
  final BridgeRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class MinorRoadOutlineLayerRenderer extends $LineLayerRenderer {
  MinorRoadOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRoadOutlineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MinorRoadOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [6.0, 7.0, 12.0, 14.0, 16.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [6.0, 7.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRoadOutlineUboWidthStops: width_stops,
    );
  }
}

class MajorRoadOutlineLayerRenderer extends $LineLayerRenderer {
  MajorRoadOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRoadOutlineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MajorRoadOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRoadOutlineUboWidthStops: width_stops,
    );
  }
}

class HighwayOutlineLayerRenderer extends $LineLayerRenderer {
  HighwayOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HighwayOutlineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final HighwayOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  6.0,
                  7.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        6.0,
        7.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      highwayOutlineUboWidthStops: width_stops,
    );
  }
}

class RoadUnderConstructionLayerRenderer extends $LineLayerRenderer {
  RoadUnderConstructionLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = RoadUnderConstructionRenderPipelineBindings(
         shaderLibraryProvider,
       );

  @override
  final RoadUnderConstructionRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color = paint.lineColor.evaluate(eval).vec;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        color: color,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [5.0, 10.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      roadUnderConstructionUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      roadUnderConstructionUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class MinorRoadLayerRenderer extends $LineLayerRenderer {
  MinorRoadLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRoadRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MinorRoadRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [5.0, 10.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRoadUboWidthStops: width_stops,
    );
  }
}

class MajorRoadLayerRenderer extends $LineLayerRenderer {
  MajorRoadLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRoadRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MajorRoadRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [10.0, 12.0, 14.0, 16.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [10.0, 12.0, 14.0, 16.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRoadUboWidthStops: width_stops,
    );
  }
}

class HighwayLayerRenderer extends $LineLayerRenderer {
  HighwayLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HighwayRenderPipelineBindings(shaderLibraryProvider);

  @override
  final HighwayRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [
                  5.0,
                  6.0,
                  10.0,
                  12.0,
                  14.0,
                  16.0,
                  20.0,
                ]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
      getNearestCeilValue(eval.zoom, const [
        5.0,
        6.0,
        10.0,
        12.0,
        14.0,
        16.0,
        20.0,
      ]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      highwayUboWidthStops: width_stops,
    );
  }
}

class PathOutlineLayerRenderer extends $LineLayerRenderer {
  PathOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PathOutlineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final PathOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pathOutlineUboWidthStops: width_stops,
    );
  }
}

class PathLayerRenderer extends $LineLayerRenderer {
  PathLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PathRenderPipelineBindings(shaderLibraryProvider);

  @override
  final PathRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 16.0, 18.0, 22.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      pathUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      pathUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class MajorRailLayerRenderer extends $LineLayerRenderer {
  MajorRailLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRailRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MajorRailRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [8.0, 16.0]),
              ),
            )
            .vec;
    final color_end_value =
        paint.lineColor
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [8.0, 16.0]),
              ),
            )
            .vec;
    final opacity = paint.lineOpacity.evaluate(eval).toDouble();
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        colorStartValue: color_start_value,
        colorEndValue: color_end_value,
        opacity: opacity,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final color_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [8.0, 16.0]),
      getNearestCeilValue(eval.zoom, const [8.0, 16.0]),
    );
    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRailUboColorStops: color_stops,
      majorRailUboWidthStops: width_stops,
    );
  }
}

class MajorRailHatchingLayerRenderer extends $LineLayerRenderer {
  MajorRailHatchingLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MajorRailHatchingRenderPipelineBindings(
         shaderLibraryProvider,
       );

  @override
  final MajorRailHatchingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final opacity = paint.lineOpacity.evaluate(eval).toDouble();
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        opacity: opacity,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      majorRailHatchingUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      majorRailHatchingUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class MinorRailLayerRenderer extends $LineLayerRenderer {
  MinorRailLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRailRenderPipelineBindings(shaderLibraryProvider);

  @override
  final MinorRailRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRailUboWidthStops: width_stops,
    );
  }
}

class MinorRailHatchingLayerRenderer extends $LineLayerRenderer {
  MinorRailHatchingLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MinorRailHatchingRenderPipelineBindings(
         shaderLibraryProvider,
       );

  @override
  final MinorRailHatchingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.5, 15.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.5, 15.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      minorRailHatchingUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      minorRailHatchingUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class BuildingLayerRenderer extends $FillLayerRenderer {
  BuildingLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BuildingRenderPipelineBindings(shaderLibraryProvider);

  @override
  final BuildingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AqueductOutlineLayerRenderer extends $LineLayerRenderer {
  AqueductOutlineLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AqueductOutlineRenderPipelineBindings(shaderLibraryProvider);

  @override
  final AqueductOutlineRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [14.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [14.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [14.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [14.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      aqueductOutlineUboWidthStops: width_stops,
    );
  }
}

class AqueductLayerRenderer extends $LineLayerRenderer {
  AqueductLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AqueductRenderPipelineBindings(shaderLibraryProvider);

  @override
  final AqueductRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [12.0, 20.0]),
      getNearestCeilValue(eval.zoom, const [12.0, 20.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      aqueductUboWidthStops: width_stops,
    );
  }
}

class CablecarLayerRenderer extends $LineLayerRenderer {
  CablecarLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CablecarRenderPipelineBindings(shaderLibraryProvider);

  @override
  final CablecarRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
      getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cablecarUboWidthStops: width_stops,
    );
  }
}

class CablecarDashLayerRenderer extends $LineLayerRenderer {
  CablecarDashLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CablecarDashRenderPipelineBindings(shaderLibraryProvider);

  @override
  final CablecarDashRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [13.0, 19.0]),
      getNearestCeilValue(eval.zoom, const [13.0, 19.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cablecarDashUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      cablecarDashUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class OtherBorderLayerRenderer extends $LineLayerRenderer {
  OtherBorderLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = OtherBorderRenderPipelineBindings(shaderLibraryProvider);

  @override
  final OtherBorderRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
      getNearestCeilValue(eval.zoom, const [3.0, 4.0, 11.0, 18.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      otherBorderUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      otherBorderUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class DisputedBorderLayerRenderer extends $LineLayerRenderer {
  DisputedBorderLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = DisputedBorderRenderPipelineBindings(shaderLibraryProvider);

  @override
  final DisputedBorderRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        lineLength: vertex.$3,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
      getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      disputedBorderUboWidthStops: width_stops,
      dasharrayTexture: lineDasharrayTexture!,
      disputedBorderUboDasharraySize: Vector2(
        lineDasharrayTexture!.width.toDouble(),
        lineDasharrayTexture!.height.toDouble(),
      ),
    );
  }
}

class CountryBorderLayerRenderer extends $LineLayerRenderer {
  CountryBorderLayerRenderer({
    required ShaderLibraryProvider shaderLibraryProvider,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CountryBorderRenderPipelineBindings(shaderLibraryProvider);

  @override
  final CountryBorderRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.LineStringFeature feature,
    int index,
    List<(Vector2 position, Vector2 normal, double lineLength)> vertexData,
  ) {
    final paint = specLayer.paint;
    final width_start_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
              ),
            )
            .toDouble();
    final width_end_value =
        paint.lineWidth
            .evaluate(
              eval.copyWithZoom(
                getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
              ),
            )
            .toDouble();

    for (var i = 0; i < vertexData.length; i++) {
      final vertex = vertexData[i];
      pipeline.vertex.setVertex(
        index + i,
        position: vertex.$1,
        normal: vertex.$2,
        widthStartValue: width_start_value,
        widthEndValue: width_end_value,
      );
    }

    return index + vertexData.length;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    double pixelRatio,
    Matrix4 tileLocalToGl,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final paint = specLayer.paint;

    final width_stops = Vector2(
      getNearestFloorValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
      getNearestCeilValue(eval.zoom, const [1.0, 5.0, 10.0, 24.0]),
    );

    pipeline.setUniforms(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      cameraPixelRatio: pixelRatio,
      tileLocalToGl: tileLocalToGl,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      countryBorderUboWidthStops: width_stops,
    );
  }
}
